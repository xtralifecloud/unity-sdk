<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CotcSdk</name>
    </assembly>
    <members>
        <member name="T:CotcSdk.Cloud">
            @ingroup main_classes
            <summary>
            Root class of the SDK. It is stateless and allows to perform basic operations with the SDK, such as
            `Ping`.
            
            The #CotcSdk.Cloud object may typically be used to log in, which would return a #CotcSdk.Gamer object, another very
            important object from the SDK.
            
            Other objects such as a #CotcSdk.CloudIndexing object can also be obtained synchronously in order to perform
            categorized operations. These objects may not be stateless though, so please refer to their
            respective documentation.
            </summary>
        </member>
        <member name="P:CotcSdk.Cloud.Game">
            <summary>Provides an API to manipulate game data, such as key/value or leaderboards.</summary>
            <returns>An object that allow to manipulate game specific data.</returns>
        </member>
        <member name="M:CotcSdk.Cloud.Index(System.String,System.String)">
            <summary>Allows to manipulate an index. Usage: `Cloud.Index("matches").IndexObject(...);`.</summary>
            <param name="indexName">Name of the index; scopes your searches.</param>
            <param name="domain">The domain to manipulate the index on.</param>
        </member>
        <member name="M:CotcSdk.Cloud.Ping">
            <summary>
            Executes a "ping" request to the server. Allows to know whether the server is currently working as expected.
            </summary>
            <returns>Promise resolved when the request has finished.</returns>
        </member>
        <member name="F:CotcSdk.Cloud.HttpRequestFailedHandler">
            <summary>
            This handler, when set, is called synchronously whenever an HTTP request fails with a recoverable
            error.
            Some errors won't call this handler and will fail directly, such as when providing invalid
            arguments. This handler rather covers network errors.
            You need to call one of the methods of the HttpRequestFailedArgs in order to tell what to do next:
            either retry or abort the request.
            Changing this value only affects the calls made later on, not the requests currently running. You
            should set it once at startup.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:CotcSdk.Cloud.ListUsers(System.String,System.Int32,System.Int32)" -->
        <member name="M:CotcSdk.Cloud.LoginAnonymously(CotcSdk.Bundle)">
            <summary>Logs the current user in anonymously.</summary>
            <returns>Task returning when the login has finished. The resulting Gamer object can then
                be used for many purposes related to the signed in account.</returns>
            <param name="additionalOptions">Additional options can be passed, such as `thenBatch` to execute a batch after
                login. Pass it as a Bundle with the additional keys.</param>
        </member>
        <member name="M:CotcSdk.Cloud.Login(System.String,System.String,System.String,CotcSdk.Bundle)">
            <summary>Logs the current user in, using any supported social network.</summary>
            <returns>Promise resolved when the login has finished. The resulting Gamer object can then be used for many
                purposes related to the signed in account.</returns>
            <param name="network">The network to connect with. If an user is recognized on a given network (same network ID),
                then it will be signed back in and its user data will be used.</param>
            <param name="networkId">The ID on the network. For example, with the facebook network, this would be the User ID.
                On e-mail accounts e-mail then, this would be the e-mail address.</param>
            <param name="networkSecret">The secret for the network. For e-mail accounts, this would be the passord. For
                facebook or other SNS accounts, this would be the user token. For the LoginNetwork.GameCenter, the password
                is not used, so you may pass "n/a".</param>
            <param name="preventRegistration">Fail instead of silently creating an account in case it doesn't already exist on
                the CotC servers.</param>
            <param name="additionalOptions">Additional options can be passed, such as `thenBatch` to execute a batch after
                login or `preventRegistration` to accept only already created accounts. Pass it as a Bundle with the additional
                keys. May not override `preventRegistration` key since it is defined by the parameter of the same name.</param>
        </member>
        <member name="M:CotcSdk.Cloud.LoginWithShortcode(System.String,CotcSdk.Bundle)">
            <summary>Logs in by using a shortcode previously generated through #SendResetPasswordEmail.</summary>
            <param name="shortcode">The shortcode received by the user by e-mail.</param>
            <param name="additionalOptions">Additional options can be passed, such as `thenBatch` to execute a batch after
                login. Pass it as a Bundle with the additional keys</param>
            <returns>Promise resolved when the login has finished. The resulting Gamer object can then be used for many
                purposes related to the signed in account.</returns>
        </member>
        <member name="M:CotcSdk.Cloud.ResumeSession(System.String,System.String,CotcSdk.Bundle)">
            <summary>
            Logs back in with existing credentials. Should be used for users who have already been logged in
            previously and the application has been quit for instance.
            </summary>
            <returns>Task returning when the login has finished. The resulting Gamer object can then
                be used for many purposes related to the signed in account.</returns>
            <param name="gamerId">Credentials of the previous session (Gamer.GamerId).</param>
            <param name="gamerSecret">Credentials of the previous session (Gamer.GamerSecret).</param>
            <param name="additionalOptions">Additional options can be passed, such as 'thenBatch' to execute a batch after
                login. Pass it as a Bundle with the additional keys</param>
        </member>
        <member name="M:CotcSdk.Cloud.Logout(CotcSdk.Gamer)">
            <summary>
            Logs out a previously logged in player.
            </summary>
            <param name="gamer">The gamer to log out.</param>
            <returns>Promise resolved when the request has finished.</returns>
        </member>
        <member name="M:CotcSdk.Cloud.SendResetPasswordEmail(System.String,System.String,System.String,System.String)">
            <summary>
            Can be used to send an e-mail to a user registered by 'email' network in order to help him
            recover his/her password.
            
            The user will receive an e-mail, containing a short code. This short code can be inputted in
            the #LoginWithShortcode method.
            </summary>
            <returns>Promise resolved when the request has finished.</returns>
            <param name="userEmail">The user as identified by his e-mail address.</param>
            <param name="mailSender">The sender e-mail address as it will appear on the e-mail.</param>
            <param name="mailTitle">The title of the e-mail.</param>
            <param name="mailBody">The body of the mail. You should include the string [[SHORTCODE]], which will
                be replaced by the generated short code.</param>
        </member>
        <member name="M:CotcSdk.Cloud.UserExists(System.String,System.String)">
            <summary>Checks that an user exists on a given network.</summary>
            <returns>Promise resolved when the user is found. If the user does not exist, it fails with
                an HTTP status code of 400.</returns>
            <param name="network">Network used to log in (scoping the networkId).</param>
            <param name="networkId">The ID of the user on the network, like the e-mail address.</param>
        </member>
        <member name="T:CotcSdk.CloudIndexing">
            @ingroup utility_classes
            <summary>Provides an API allowing to manipulate an index.</summary>
        </member>
        <member name="M:CotcSdk.CloudIndexing.DeleteObject(System.String)">
            <summary>Deletes an indexed entry. If you just want to update an entry, simply use IndexObject.</summary>
            <returns>Promise resolved when the request has finished.</returns>
            <param name="objectId">ID of the object to delete, as passed when indexing.</param>
        </member>
        <member name="M:CotcSdk.CloudIndexing.GetObject(System.String)">
            <summary>Fetches a previously indexed object.</summary>
            <returns>Promise resolved when the request has finished.</returns>
            <param name="objectId">ID of the object to look for, as passed when indexing.</param>
        </member>
        <member name="M:CotcSdk.CloudIndexing.IndexObject(System.String,CotcSdk.Bundle,CotcSdk.Bundle)">
            <summary>
            Indexes a new object.
            Use this API to add or update an object in an index. You can have as many indexes as you need: one
            for gamer properties, one for matches, one for finished matches, etc. It only depends on what you
            want to search for.
            </summary>
            <returns>Promise resolved when the request has finished.</returns>
            <param name="objectId">The ID of the object to be indexed. It can be anything; this ID only needs to uniquely
                identify your document. Therefore, using the match ID to index a match is recommended for instance.</param>
            <param name="properties">A freeform object, whose attributes will be indexed and searchable. These properties
                are typed! So if 'age' is once passed as an int, it must always be an int, or an error will be
                thrown upon insertion.</param>
            <param name="payload">Another freeform object. These properties are attached to the document in the same way
                as the properties, however those are not indexed (cannot be looked for in a search request). Its
                content is returned in searches (#CotcSdk.IndexResult.Payload property).</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:CotcSdk.CloudIndexing.Search(System.String,System.Collections.Generic.List{System.String},System.Int32,System.Int32)" -->
        <member name="M:CotcSdk.CloudIndexing.SearchExtended(CotcSdk.Bundle,System.Int32,System.Int32)">
             <summary>
             Alternative search function (see #Search for more information) that takes a bundle as a search criteria.
             
             It allows using the full Elastic search capabilities with full query DSL search. The query bundle represents
             the JSON document as documented here:
             https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html
            
             </summary>
             <returns>Promise resolved when the operation has finished. The attached object contains various
                 information about the results, including a Hits member, which handles the results in a
                 paginated way.</returns>
             <param name="query">Search query as described in the summary.</param>
             <param name="limit">The maximum number of results to return per page.</param>
             <param name="offset">Number of the first result.</param>
        </member>
        <member name="T:CotcSdk.GamerStore">
            @ingroup gamer_classes
            <summary>(App) Store API.</summary>
        </member>
        <member name="M:CotcSdk.GamerStore.ListConfiguredProducts(System.Int32,System.Int32)">
            <summary>
            Fetch the list of products as configured on the backoffice. Note that this doesn't include any information
            about pricing and so on: the external store plugin is required to do so.
            Note that this call returns the catalog as configured on the CotC server, which may not be exhaustive if
            additional products are configured on iTunes Connect but not reported to the CotC servers.
            </summary>
            <param name="limit">The maximum number of results to return per page.</param>
            <param name="offset">Number of the first result.</param>
            <returns>Promise resolved when the operation has completed. The attached value describes a list of products,
                with pagination functionality.</returns>
        </member>
        <member name="M:CotcSdk.GamerStore.GetPurchaseHistory">
            <summary>
            Fetches the list of transactions made by the logged in user. Only successful transactions
            show here.
            </summary>
            <returns>Promise resolved when the operation has completed. The attached value describes a list of purchase
                transactions, without pagination functionality.</returns>
        </member>
        <member name="M:CotcSdk.GamerStore.ValidateReceipt(CotcSdk.StoreType,System.String,System.Single,System.String,System.String)">
            <summary>
            Last step in the purchase. Validates the receipt received by a native purchase. You may have to do additional
            steps to close your purchase process.
            </summary>
            <returns>Promise indicating whether the recceipt was validated properly. In case of exception, you can inspect why
                the receipt failed to verify.</returns>
            <param name="storeType">Type of Store, should be provided by the store plugin. Valid are appstore, macstore, googleplay.</param>
            <param name="cotcProductId">ID of the product purchased (as configured on the backoffice).</param>
            <param name="paidPrice">Paid price in units.</param>
            <param name="paidCurrency">Currency of paid price (ISO code).</param>
            <param name="receipt">Receipt string, dependent on the store type.</param>
        </member>
        <member name="T:CotcSdk.Cotc">
            @cond private 
            @cond private
            Events to be used by plugins. 
        </member>
        <member name="M:CotcSdk.Cotc.Setup(System.String,System.String,System.String,System.Int32,System.Boolean,System.Int32,System.Int32)">
            <summary>Call this at the very beginning to start using the library.</summary>
            <returns>Promise resolved when the process has finished, with the Cloud to be used for your operations (most
                likely synchronously).</returns>
            <param name="apiKey">The community key.</param>
            <param name="apiSecret">The community secret (credentials when registering to CotC).</param>
            <param name="environment">The URL of the server. Should use one of the predefined constants.</param>
            <param name="httpVerbose">Set to true to output detailed information about the requests performed to CotC servers. Can be used
                for debugging, though it does pollute the logs.</param>
            <param name="httpTimeout">Sets a custom timeout for all requests in seconds. Defaults to 1 minute.</param>
            <param name="httpType">HTTP layer to be used. Currently 0 is the default (mono-based) one. Works pretty well, but is severely
                aged has a few issues on some platforms (which are all overcomable). Type 1 uses the new
                UnityEngine.Experimental.Networking.UnityWebRequest class and is also supported on all platforms.</param>
        </member>
        <member name="M:CotcSdk.Cotc.OnApplicationFocus(System.Boolean)">
            <summary>
            Please call this in an override of OnApplicationFocus on your main object (e.g. scene).
            http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnApplicationFocus.html
            </summary>
        </member>
        <member name="M:CotcSdk.Cotc.OnApplicationQuit">
            <summary>
            Shuts off the existing instance of the Cloud and its descendent objects.
            Works synchronously so might take a bit of time.
            </summary>
        </member>
        <member name="M:CotcSdk.Cotc.Update(UnityEngine.MonoBehaviour)">
            <summary>
            Needs to be called from the update method of your main game object.
            Not needed if the CotcGameObject is used...
            <param name="host">Host object for coroutines.</param>
            </summary>
        </member>
        <member name="M:CotcSdk.Cotc.RunOnMainThread(System.Action)">
            <summary>Runs a method on the main thread (actually at the next update).</summary>
        </member>
        <member name="T:CotcSdk.CotcGameObject">
            @ingroup main_classes
            <summary>
            Place this object on all scenes where you would like to use CotC functionality, as described @ref cotcgameobject_ref "in this tutorial".
            
            Then call #GetCloud to get a Cloud object, which provides an entry point (through sub objects) to all functionality provided by the SDK.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:CotcSdk.CotcGameObject.GetCloud" -->
        <member name="T:CotcSdk.Common">
            @ingroup utility_classes
            <summary>Common SDK methods also usable by clients.</summary>
        </member>
        <member name="M:CotcSdk.Common.HasFailed(CotcSdk.HttpResponse)">
            <summary>
            Checks whether the response is negative (either it has failed completely,
            either it has given an error status code. You should not attempt to process
            the entity from the response if this method return yes. Just build a Result
            object with the response in question, add an error message and invoke the
            result handler with it.
            </summary>
            <returns>Whether the server response is considered as failed</returns>
        </member>
        <member name="M:CotcSdk.Common.RunRequest``1(CotcSdk.HttpRequest,CotcSdk.Promise{``0},System.Action{CotcSdk.HttpResponse},CotcSdk.HttpClient)">
            <summary>
            Wrapper around our standard work on Managers.HttpClient.Run. Automatically notifies the passed handler
            of a failure.
            </summary>
            <param name="req">Request to perform.</param>
            <param name="task">Task that is resolved in case of failure, else the onSuccess callback is called and you'll
                have to resolve it from inside.</param>
            <param name="onSuccess">Callback called in case of success only.</param>
            <param name="forceClient">Leave it to null, unless you really need a special HTTP client to be used.</param>
        </member>
        <member name="M:CotcSdk.Common.RunInTask``1(CotcSdk.HttpRequest,System.Action{CotcSdk.HttpResponse,CotcSdk.Promise{``0}})">
            <summary>
            Wrapper around our standard work on Managers.HttpClient.Run. Automatically notifies the passed handler
            of a failure.
            </summary>
            <param name="req">Request to perform.</param>
            <returns>A task that is resolved in case of failure (the onSuccess callback is not called) or to be resolved
                from the onSuccess block in case of success.</returns>
            <param name="onSuccess">Callback called in case of success only, with the response and a new task that needs to
                be resolved from there.</param>
        </member>
        <member name="T:CotcSdk.CachedMember`1">
            <summary>Holds a cached single-time-instantiated member.</summary>
        </member>
        <member name="T:CotcSdk.LogEventArgs">
            <summary>Information about a log entry.</summary>
        </member>
        <member name="T:CotcSdk.GamerGodfather">
            @ingroup gamer_classes
            <summary>Godfather (code) related functions. You may also want to subscribe to events (see #CotcSdk.GamerGodfather.OnGotGodchild).</summary>
        </member>
        <member name="E:CotcSdk.GamerGodfather.OnGotGodchild">
            <summary>Event triggered when someone adds this gamer as a friend or changes his friendship status.</summary>
        </member>
        <member name="M:CotcSdk.GamerGodfather.Domain(System.String)">
            <summary>
            Changes the domain affected by the next operations.
            You should typically use it this way: `gamer.Godfather.Domain("private").Associate(...);`
            </summary>
            <param name="domain">Domain on which to scope the next operations.</param>
            <returns>This object for operation chaining.</returns>
        </member>
        <member name="M:CotcSdk.GamerGodfather.DiscardEventHandlers">
            <summary>
            Clears all event handlers subscribed, ensuring that a match object can be dismissed without causing further
            actions in the background.
            </summary>
        </member>
        <member name="M:CotcSdk.GamerGodfather.GenerateCode">
             <summary>
             Method to call in order to generate a temporary code that can be passed to another gamer so he can
             add us as a godfather.
             
             The domain as specified by the #Domain method is the domain in which the godfather link should be
             established. "private" means it's local to this game only.
            
             </summary>
             <returns>Promise resolved when the operation has completed. The attached string is the generated code.</returns>
        </member>
        <member name="M:CotcSdk.GamerGodfather.GetGodchildren">
            <summary>This method can be used to retrieve the gamer who have added you as a godfather.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
        </member>
        <member name="M:CotcSdk.GamerGodfather.GetGodfather">
            <summary>This method can be used to retrieve the godfather of the gamer.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
        </member>
        <member name="M:CotcSdk.GamerGodfather.UseCode(System.String,CotcSdk.Bundle,CotcSdk.PushNotification)">
            <summary>Call this to attribute a godfather to the currently logged in user.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="code">Is a string as generated by #GenerateCode.</param>
            <param name="rewardTx">A transaction Json rewarding the godfather formed as follows:
                { transaction : { "unit" : amount},
                description : "reward transaction",
                domain : "com.clanoftcloud.text.DOMAIN" }
                where description and domain are optional.</param>
            <param name="notification">Optional OS notification to be sent to the godfather who generated the code.
                The godfather will reveive an event of type 'godchildren' containing the id of the godchildren
                and the balance/achievements field if rewarded.</param>
        </member>
        <member name="T:CotcSdk.GotGodchildEvent">
            <summary>
            Event triggered when a godfather code is used. This event is received by the one who originated the code
            (godfather). See #CotcSdk.GamerGodfather.GenerateCode.
            </summary>
        </member>
        <member name="F:CotcSdk.GotGodchildEvent.Gamer">
            <summary>Gamer who accepted the godfather request.</summary>
        </member>
        <member name="F:CotcSdk.GotGodchildEvent.Reward">
            <summary>Reward transaction executed if any.</summary>
        </member>
        <member name="T:CotcSdk.GameBatches">
            @ingroup game_classes
            <summary>
            Allows to run batches authenticated as a game (that is, unauthenticated).</summary>
        </member>
        <member name="M:CotcSdk.GameBatches.Domain(System.String)">
            <summary>
            Changes the domain affected by the next operations.
            You should typically use it this way: `gamer.Batches.Domain("private").Run(...);`
            </summary>
            <param name="domain">Domain on which to scope the next operations.</param>
            <returns>This object for operation chaining.</returns>
        </member>
        <member name="M:CotcSdk.GameBatches.Run(System.String,CotcSdk.Bundle)">
            <summary>Runs a batch on the server, unauthenticated (game-scoped).</summary>
            <returns>Promise resolved when the request has finished. The attached bundle is the JSON data returned by the match.</returns>
            <param name="batchName">Name of the batch to run, as configured on the server.</param>
            <param name="batchParams">Parameters to be passed to the batch.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:CotcSdk.GamerAchievements" -->
        <member name="M:CotcSdk.GamerAchievements.Domain(System.String)">
            <summary>
            Changes the domain affected by the next operations.
            You should typically use it this way: `gamer.Achievements.Domain("private").List(...);`
            </summary>
            <param name="domain">Domain on which to scope the next operations.</param>
            <returns>This object for operation chaining.</returns>
        </member>
        <member name="M:CotcSdk.GamerAchievements.AssociateData(System.String,CotcSdk.Bundle)">
            <summary>
            Allows to store arbitrary data for a given achievement and the current player (appears in the
            'gamerData' node of achievements).
            </summary>
            <returns>Promise resolved when the operation has completed. The attached value contains the updated definition
                of the achievement.</returns>
            <param name="achName">Name of the achievement to update.</param>
            <param name="data">Data to associate with the achievement, merged with the current data (that is, existing keys
                are not affected)</param>
        </member>
        <member name="M:CotcSdk.GamerAchievements.List">
            <summary>Fetches information about the status of the achievements configured for this game.</summary>
            <returns>Promise resolved when the operation has completed. The attached value is the list of achievements
                with their current state.</returns>
        </member>
        <member name="T:CotcSdk.GamerBatches">
            @ingroup gamer_classes
            <summary>Allows to run batches authenticated as a user.</summary>
        </member>
        <member name="M:CotcSdk.GamerBatches.Domain(System.String)">
            <summary>
            Changes the domain affected by the next operations.
            You should typically use it this way: `gamer.Batches.Domain("private").Run(...);`
            </summary>
            <param name="domain">Domain on which to scope the next operations.</param>
            <returns>This object for operation chaining.</returns>
        </member>
        <member name="M:CotcSdk.GamerBatches.Run(System.String,CotcSdk.Bundle)">
            <summary>Runs a batch on the server, authenticated as a gamer (gamer-scoped).</summary>
            <returns>Promise resolved when the operation has completed. The attached bundle is the JSON data returned
                by the batch.</returns>
            <param name="batchName">Name of the batch to run, as configured on the server.</param>
            <param name="batchParams">Parameters to be passed to the batch.</param>
        </member>
        <member name="T:CotcSdk.GamerMatches">
            @ingroup gamer_classes
            <summary>
            Some methods accept a PushNotification parameter. This parameter can be used to forward a push notification to the
            users who are not active at the moment.
            </summary>
        </member>
        <member name="M:CotcSdk.GamerMatches.Create(System.Int32,System.String,CotcSdk.Bundle,CotcSdk.Bundle,CotcSdk.Bundle)">
            <summary>
            Creates a match, available for join by other players. If you would like to make your match private, please read
            the general documentation about matches.
            </summary>
            <returns>Promise resolved when the operation has completed. The attached Match object allows to operate with the
                match.</returns>
            <param name="maxPlayers">The maximum number of players who may be in the game at a time.</param>
            <param name="description">String describing the match (available for other who want to join).</param>
            <param name="customProperties">Freeform object containing the properties of the match, which may be used by other players
                to search for a suited match.</param>
            <param name="shoe">Freeform object containing a list of objects which will be shuffled upon match creation. This offers
                an easy way to make a random generator that is safe, unbiased (since made on the server) and can be verified
                by all players once the game is finished. This bundle needs to be an array (use Bundle.CreateArray).</param>
            <param name="globalState">Global state you want to attach to the match.</param>
        </member>
        <member name="M:CotcSdk.GamerMatches.Delete(System.String)">
            <summary>Deletes a match. Only works if you are the one who created it and it is already finished.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="matchId">ID of the match to delete.</param>
        </member>
        <member name="M:CotcSdk.GamerMatches.DismissInvitation(System.String)">
            <summary>Dismisses an invitation to a match.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="matchId">ID of the match where invitation is dismissed.</param>
        </member>
        <member name="M:CotcSdk.GamerMatches.DiscardEventHandlers">
            <summary>
            Clears all event handlers subscribed, ensuring that a match object can be dismissed without causing further
            actions in the background.
            </summary>
        </member>
        <member name="M:CotcSdk.GamerMatches.Domain(System.String)">
            <summary>
            Changes the domain affected by the next operations.
            You should typically use it this way: `gamer.Matches.Domain("private").List(...);`
            </summary>
            <param name="domain">Domain on which to scope the matches. Default to `private` if unmodified.</param>
            <returns>This object for operation chaining.</returns>
        </member>
        <member name="M:CotcSdk.GamerMatches.Fetch(System.String)">
            <summary>
            Fetches a Match object corresponding to a match which the player already belongs to.
            It can be used either to obtain additional information about a running match (by inspecting the resulting
            match object), or to continue an existing match (by keeping the match object which corresponds to the one
            that was returned by the Create method).
            This call is not scoped by domain (it uses the Match ID directly).
            </summary>
            <returns>Promise resolved when the operation has completed. The attached Match object allows to operate with
                the match.</returns>
            <param name="matchId">The ID of an existing match to resume. It can be fetched from the Match object (MatchId).</param>
        </member>
        <member name="M:CotcSdk.GamerMatches.Join(System.String,CotcSdk.PushNotification)">
            <summary>
            Asks to join the match with a given ID. Do not use this if you are already part of the match.
            This call is not scoped by domain (it uses the Match ID directly).
            </summary>
            <returns>Promise resolved when the operation has completed. In case of success, you get the exact same
                match object that would be returned by a call to Create or Fetch. It can be used to interact with
                the match as the user who just joined.</returns>
            <param name="matchId">The ID of an existing match to join. It can be fetched from the Match object (MatchId).</param>
            <param name="notification">Optional push notification to be sent to inactive players (see class definition).</param>
        </member>
        <member name="M:CotcSdk.GamerMatches.List(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Can be used to list the active matches for this game. In general, it is not recommended to proceed this way
            if your goal is to display the games that may be joined. The indexing API is better suited to this use case
            (index the match along with properties and look for matches matching the desired properties).
            </summary>
            <returns>Promise resolved when the operation has completed. The list of matches filtered according to the
                following parameters is provided.</returns>
            <param name="participating">Set to true to only list matches to which this user is participating.</param>
            <param name="invited">Set to true to filter by matches you are invited to (only include them).</param>
            <param name="finished">Set to true to also include finished matchs (which are filtered out by default).</param>
            <param name="full">Set to true to also include games where the maximum number of players has been reached.</param>
            <param name="limit">For pagination, allows to set a greater or smaller page size than the default 30.</param>
            <param name="offset">For pagination, avoid using it explicitly.</param>
        </member>
        <member name="T:CotcSdk.GamerCommunity">
            @ingroup gamer_classes
            <summary>
            API methods related to the friends and so on of one gamer.
            
            You may also want to subscribe to related events (see #CotcSdk.GamerCommunity.OnFriendStatusChange).
            </summary>
        </member>
        <member name="E:CotcSdk.GamerCommunity.OnFriendStatusChange">
            <summary>Event triggered when someone adds this gamer as a friend or changes his friendship status.</summary>
        </member>
        <member name="M:CotcSdk.GamerCommunity.AddFriend(System.String,CotcSdk.PushNotification)">
            <summary>Easy way to add a friend knowing his gamer ID inside the CotC community.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="gamerId">ID of the gamer to add as a friend (fetched using ListFriends for instance).</param>
            <param name="notification">Optional OS notification to be sent to indicate the player that the status has changed.</param>
        </member>
        <member name="M:CotcSdk.GamerCommunity.ChangeRelationshipStatus(System.String,CotcSdk.FriendRelationshipStatus,CotcSdk.PushNotification)">
            <summary>Allows to change the relation of a friendship inside the application.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="gamerId">ID of the gamer to change the relationship (fetched using ListFriends for instance).</param>
            <param name="state">The new state to set.</param>
            <param name="notification">Optional OS notification to be sent to indicate the player that the status has changed.</param>
        </member>
        <member name="M:CotcSdk.GamerCommunity.DiscardEventHandlers">
            <summary>
            Clears all event handlers subscribed, ensuring that a match object can be dismissed without causing further
            actions in the background.
            </summary>
        </member>
        <member name="M:CotcSdk.GamerCommunity.Domain(System.String)">
            <summary>
            Changes the domain affected by the next operations.
            You should typically use it this way: `gamer.Community.Domain("private").ListFriends(...);`
            </summary>
            <param name="domain">Domain on which to scope the next operations.</param>
            <returns>This object for operation chaining.</returns>
        </member>
        <member name="M:CotcSdk.GamerCommunity.ListFriends(System.Boolean)">
            <summary>Method used to retrieve the application's friends of the currently logged in profile.</summary>
            <returns>Promise resolved when the operation has completed, with the fetched list of friends.</returns>
            <param name="filterBlacklisted">When set to true, restricts to blacklisted friends.</param>
        </member>
        <member name="M:CotcSdk.GamerCommunity.ListNetworkFriends(CotcSdk.LoginNetwork,System.Collections.Generic.List{CotcSdk.SocialNetworkFriend},System.Boolean)">
            <summary>
            When you have data about friends from another social network, you can post them to CotC servers using
            these function.
            This will automatically add them as a friend on CotC as they get recognized on our servers.
            The friends get associated to the domain of this object.
            Note: this function was once called PostSocialNetworkFriends but renamed due to it being misleading.
            </summary>
            <returns>Promise resolved when the operation has completed. The attached value is the same list as passed,
                enriched with potential information about the gamer (member #CotcSdk.SocialNetworkFriend.ClanInfo) for
                gamers who are already registered on CotC servers.</returns>
            <param name="network">The network with which these friends are associated.</param>
            <param name="friends">A list of data about the friends fetched on the social network.</param>
            <param name="automatching">If true, synchronizes the CotC friends with the list. That is, the provided
            social network friends become your friends on CotC as well (reported on ListFriends and such).</param>
        </member>
        <member name="M:CotcSdk.GamerCommunity.SendEvent(System.String,CotcSdk.Bundle,CotcSdk.PushNotification)">
             <summary>
             Use this method to send a message to another user from your game.
             
             Messages are sent to a specific user, in a specific domain. You can use domains to send messages
             across games (or use private for messages sent to your game only).
            
             </summary>
             <returns>Promise resolved when the operation has completed.</returns>
             <param name="gamerId">ID of the recipient gamer.</param>
             <param name="eventData">JSON object representing the event to be sent. The recipient will receive it as is
                 when subscribed to a #CotcSdk.DomainEventLoop (ReceivedEvent property). If the application is not active,
                 the message will be queued and transmitted the next time the domain event loop is started.</param>
             <param name="notification">Push notification to send to the recipient player if not currently active.</param>
        </member>
        <member name="T:CotcSdk.FriendRelationshipStatus">
            <summary>Status of friend relationship.</summary>
        </member>
        <member name="T:CotcSdk.FriendStatusChangeEvent">
            <summary>Event triggered when someone adds this gamer as a friend or changes his friendship status.</summary>
        </member>
        <member name="F:CotcSdk.FriendStatusChangeEvent.FriendId">
            <summary>Gamer ID of the friend affected.</summary>
        </member>
        <member name="F:CotcSdk.FriendStatusChangeEvent.NewStatus">
            <summary>New relationship status.</summary>
        </member>
        <member name="T:CotcSdk.GamerScores">
            @ingroup gamer_classes
            <summary>Scoring and leaderboard related functions.</summary>
        </member>
        <member name="M:CotcSdk.GamerScores.Domain(System.String)">
            <summary>
            Changes the domain affected by the next operations.
            You should typically use it this way: `game.Scores.Domain("private").Post(...);`
            </summary>
            <param name="domain">Domain on which to scope the next operations.</param>
            <returns>This object for operation chaining.</returns>
        </member>
        <member name="M:CotcSdk.GamerScores.BestHighScores(System.String,System.Int32,System.Int32)">
            <summary>Fetch the score list for a given board.</summary>
            <returns>Promise resolved when the operation has completed. The attached value describes a list of scores, and
                provides pagination functionality.</returns>
            <param name="board">The name of the board to fetch scores from.</param>
            <param name="count">The maximum number of results to return per page.</param>
            <param name="page">Number of the page to be fetched. After that, you may use the paged result handler to fetch pages nearby.</param>
        </member>
        <member name="M:CotcSdk.GamerScores.ListFriendScores(System.String)">
            <summary>Fetch the score list for a given board, restricting to the scores made by the friends of the current user.</summary>
            <returns>Promise resolved when the operation has completed. The attached value describes a list of scores,
                without pagination functionality.</returns>
            <param name="board">The name of the board to fetch scores from.</param>
        </member>
        <member name="M:CotcSdk.GamerScores.PagedCenteredScore(System.String,System.Int32)">
            <summary>Fetch the score paged list around the player.</summary>
            <returns>Promise resolved when the operation has completed. The attached value describes a list of scores,
                with pagination functionality.</returns>
            <param name="board">The name of the board to fetch scores from.</param>
            <param name="count">The maximum number of results to return per page.</param>
        </member>
        <member name="M:CotcSdk.GamerScores.ListUserBestScores">
            <summary>Retrieves the best scores of this gamer, on all board he has posted one score to.</summary>
            <returns>Promise resolved when the operation has completed. The attached value contains information about
                the best scores of the user, indexed by board name.
                *IMPORTANT*: in the results, the gamer information is not provided. GamerInfo is always null.</returns>
        </member>
        <member name="M:CotcSdk.GamerScores.GetRank(System.Int64,System.String)">
            <summary>Retrieves the rank that a given score would have on the leaderboard, without actually registering the score.</summary>
            <returns>Promise resolved when the operation has completed. The attached value contains the rank that the
                score would have (position in the board).</returns>
            <param name="score">The score (numeric value) to check for ranking.</param>
            <param name="board">The name of the board to check the ranking against. Should match the board where a score has
                already been posted.</param>
        </member>
        <member name="M:CotcSdk.GamerScores.Post(System.Int64,System.String,CotcSdk.ScoreOrder,System.String,System.Boolean)">
            <summary>Post a score.</summary>
            <returns>Promise resolved when the operation has completed. The attached value contains the new rank of the
                player as well as whether the score was saved.</returns>
            <param name="score">The score (numeric value) to record.</param>
            <param name="board">The name of the board to post the score to. You may have as many boards as you like for your
                game, and scores are scoped between them.</param>
            <param name="order">The order for this board. As board are not configured on the server, any client can create a
                board dynamically. This parameter serves as as a description for the board and is used only upon
                creation (that is, the first player posting to the named board).</param>
            <param name="scoreInfo">An optional string used to describe the score made by the user.</param>
            <param name="forceSave">When set to true, the score is saved even if its value is less than the past best score
                for this player.</param>
        </member>
        <member name="T:CotcSdk.ScoreOrder">
            <summary>Describes the possible sorting orders for the score leaderboard.</summary>
        </member>
        <member name="T:CotcSdk.GameVfs">
            @ingroup gamer_classes
            <summary>
            Represents a key/value system, also known as virtual file system, to be used for game properties.
            This class is scoped by domain, meaning that you can call .Domain("yourdomain") and perform
            additional calls that are scoped.
            </summary>
        </member>
        <member name="M:CotcSdk.GameVfs.Domain(System.String)">
            <summary>
            Sets the domain affected by this object.
            You should typically use it this way: `gamer.GamerVfs.Domain("private").SetKey(...);`
            </summary>
            <param name="domain">Domain on which to scope the VFS. Defaults to `private` if not specified.</param>
            <returns>This object, so you can chain operations</returns>
        </member>
        <member name="M:CotcSdk.GameVfs.GetAll">
            <summary>Retrieves all keys from the key/value system for the current domain.</summary>
            <returns>Promise resolved when the operation has completed. The attached bundle contains the keys
                along with their values. If you would like to fetch the value of a given key and you expect
                it to be a string, you may simply do `string value = result.Value["key"];`.</returns>
            <remarks>This method is obsolete, use GetValue instead.</remarks>
        </member>
        <member name="M:CotcSdk.GameVfs.GetKey(System.String)">
            <summary>Retrieves an individual key from the key/value system.</summary>
            <returns>Promise resolved when the operation has completed. The attached bundle contains the fetched property.
                As usual with bundles, it can be casted to the proper type you are expecting.
                If the property doesn't exist, the call is marked as failed with a 404 status.</returns>
            <param name="key">The name of the key to be fetched.</param>
            <remarks>This method is obsolete, use GetValue instead.</remarks>
        </member>
        <member name="M:CotcSdk.GameVfs.GetValue(System.String)">
            <summary>Retrieves an individual key or all keys from the key/value system.</summary>
            <returns>Promise resolved when the operation has completed. The attached bundle contains the fetched property(ies).
                As usual with bundles, it can be casted to the proper type you are expecting.
                If the property doesn't exist, the call is marked as failed with a 404 status.</returns>
            <param name="key">The name of the key to be fetched.</param>
        </member>
        <member name="M:CotcSdk.GameVfs.GetBinary(System.String)">
            <summary>Retrieves the binary data of game key from the key/value system.</summary>
            <returns>Promise resolved when the operation has completed. The binary data is attached as the value
                of the result. Please ensure that the key was set with binary data before, or this call will
                fail with a network error.</returns>
            <param name="key">The name of the key to be fetched.</param>
        </member>
        <member name="T:CotcSdk.EventLoopHandler">
            @ingroup data_classes
            <summary>
            Delegate called when receiving a message on a #CotcSdk.DomainEventLoop.</summary>
            <param name="sender">Domain loop that triggered the event.</param>
            <param name="e">Description of the received event.</param>
        </member>
        <member name="T:CotcSdk.EventLoopArgs">
            @ingroup data_classes
            <summary>
            Arguments of the EventLoopArgs.ReceivedEvent event. You can use `args.Message.ToJson()` to
            obtain more information.
            </summary>
        </member>
        <member name="P:CotcSdk.EventLoopArgs.Message">
            <summary>Message received.</summary>
        </member>
        <member name="T:CotcSdk.DomainEventLoop">
            @ingroup main_classes
            <summary>
            This class is responsible for polling the server waiting for new events.
            You should instantiate one and manage its lifecycle as the state of the application changes.
            
            A loop is typically managed through the Gamer.StartEventLoop method (loops are always running as an authenticated
            gamer) and should be started once the gamer is logged in, and stopped at logout. The loop is automatically paused
            by the system when the user leaves the application, and automatically restarted as well.
            
            @code{.cs}
            DomainEventLoop loop;
            
            void Login() {
                Cloud.LoginAnonymous()
                .Then(gamer => {
                    loop = gamer.StartEventLoop();
                    loop.ReceivedEvent += ReceivedEvent;
                });
            }
            
            void Logout() {
                loop.Stop();
            }
            
            void ReceivedEvent(DomainEventLoop sender, EventLoopArgs e) {
                Debug.Log("Received event of type " + e.Message.Type + ": " + e.Message.ToJson());
            } @endcode
            </summary>
        </member>
        <member name="M:CotcSdk.DomainEventLoop.#ctor(CotcSdk.Gamer,System.String,System.Int32)">
            <summary>
            You need valid credentials in order to instantiate this class. Use Cloud.Login* methods for that purpose.
            Once the object is created, you need to start the coroutine, please look at the other methods available.
            </summary>
            <param name="gamer">The gamer object received from a login or similar function.</param>
            <param name="domain">The domain on which to listen for events. Note that you may create multiple event loops,
                especially if you are using multiple domains. The default domain, that you should use unless you are
                explicitly using multiple domains, is the private domain.</param>
            <param name="gamer">Gamer, used to authenticate (receive events related to the said gamer).</param>
            <param name="domain">Domain on which to listen for events.</param>
            <param name="iterationDuration">Sets a custom timeout in seconds for the long polling event loop. Should be used
                with care and set to a high value (at least 60). Defaults to 590 (~10 min).</param>
        </member>
        <member name="P:CotcSdk.DomainEventLoop.Domain">
            <summary>The domain on which this loop is listening.</summary>
        </member>
        <member name="E:CotcSdk.DomainEventLoop.ReceivedEvent">
            <summary>This event is raised when an event is received.</summary>
        </member>
        <member name="M:CotcSdk.DomainEventLoop.Start">
            <summary>Starts the coroutine. Call this upon initialization.</summary>
        </member>
        <member name="M:CotcSdk.DomainEventLoop.Stop">
            <summary>
            Will stop the event coroutine. Might take some time until the current request finishes.
            You should not use this object for other purposes later on. In particular, do not start it again.
            </summary>
        </member>
        <member name="M:CotcSdk.DomainEventLoop.Suspend">
            <summary>Suspends the event coroutine.</summary>
        </member>
        <member name="M:CotcSdk.DomainEventLoop.Resume">
            <summary>Resumes a suspended event coroutine.</summary>
        </member>
        <member name="T:CotcSdk.ErrorCode">
            @ingroup data_classes
            <summary>
            Represents an error code as returned by a CotcException.
            </summary>
        </member>
        <member name="F:CotcSdk.ErrorCode.Ok">
            No error.
        </member>
        <member name="F:CotcSdk.ErrorCode.LastError">
            You shouldn't receive this error, it's just a convenient value
        </member>
        <member name="T:CotcSdk.Game">
            @ingroup main_classes
            <summary>
            Provides functionality related to the entire game.
            </summary>
        </member>
        <member name="P:CotcSdk.Game.Batches">
            <summary>Provides an API to run game-scoped (unauthenticated) batches.</summary>
            <returns>An object that allows to manipulate batches.</returns>
        </member>
        <member name="P:CotcSdk.Game.GameVfs">
            <summary>Returns an object that allows to manipulate the key/value system associated with this game.</summary>
            <returns>An object allowing to manipulate key/values for this user/game/domain.</returns>
        </member>
        <member name="T:CotcSdk.Gamer">
            @ingroup main_classes
            <summary>
            Important object from the SDK, allowing to perform many operations that depend on a currently logged in user.
            
            This object is almost stateless. You may drop it without worrying about background processes that may still
            run. User related events are handled by a corresponding instance of DomainEventLoop, which should be started
            as soon as the user is logged in.
            </summary>
        </member>
        <member name="P:CotcSdk.Gamer.GamerId">
            <summary>Gamer credential. Use it to gain access to user related tasks.</summary>
        </member>
        <member name="P:CotcSdk.Gamer.GamerSecret">
            <summary>Gamer credential (secret). Same purpose as GamerId, and you will need those in pair.</summary>
        </member>
        <member name="P:CotcSdk.Gamer.Account">
            <summary>Provides account related functions for the current gamer.</summary>
            <returns>An object allowing to manipulate the account of the current gamer.</returns>
        </member>
        <member name="P:CotcSdk.Gamer.Achievements">
            <summary>Provides an API to manipulate achievements.</summary>
            <returns>An object that allows to manipulate achievements.</returns>
        </member>
        <member name="P:CotcSdk.Gamer.Batches">
            <summary>Provides an API to run batches.</summary>
            <returns>An object that allows to manipulate batches.</returns>
        </member>
        <member name="P:CotcSdk.Gamer.Community">
            <summary>Provides an API to interact with friends on CotC.</summary>
            <returns>An object that allow to manipulate friends.</returns>
        </member>
        <member name="P:CotcSdk.Gamer.GamerVfs">
            <summary>Returns an object that allows to manipulate the key/value system associated with this user.</summary>
            <returns>An object allowing to manipulate key/values for this user/domain.</returns>
        </member>
        <member name="P:CotcSdk.Gamer.Godfather">
            <summary>Exposes functionality related to the godfathers.</summary>
            <returns>An object that allows to add a godfather, generate a code, etc.</returns>
        </member>
        <member name="P:CotcSdk.Gamer.Matches">
            <summary>
            Provides an API to manipulate matches (mainly start them, since working with
            existing matches is provided by the Match class).
            </summary>
            <returns>An object that allows to perform basic operations on matches.</returns>
        </member>
        <member name="P:CotcSdk.Gamer.Profile">
            <summary>Allows to manipulate information related to the gamer profile.</summary>
            <returns>An object that allows to read and set the profile.</returns>
        </member>
        <member name="P:CotcSdk.Gamer.Properties">
            <summary>Allows to manipulate the properties of the current gamer.</summary>
            <returns>An object that allows to set, delete, etc. property values.</returns>
        </member>
        <member name="P:CotcSdk.Gamer.Scores">
            <summary>Provides an API able to handle functionality related to the leaderboards and scores.</summary>
            <returns>An object that allows to manipulate scores.</returns>
        </member>
        <member name="P:CotcSdk.Gamer.Store">
            <summary>
            Allows to list, buy products and so on. This functionality is low level and you should use the
            appropriate external plugin to help with the purchase process.
            </summary>
            <returns>An object that allows access to the store on a CotC point of view.</returns>
        </member>
        <member name="P:CotcSdk.Gamer.Transactions">
            <summary>Allows to manipulate the transactions and related achievements of an user.</summary>
            <returns>An object that allows to manipulate transactions and query achievements.</returns>
        </member>
        <member name="M:CotcSdk.Gamer.StartEventLoop(System.String)">
             <summary>
             Starts a DomainEventLoop in order to catch events related to this logged in gamer.
             
             The loop will be running forever unless an error happens with this gamer (meaning that the
             gamer is not valid anymore, which can happen if he's not logged in). When stopping
             or pausing the application, you should call the corresponding methods on the loop to stop
             or pause it. The system will pause the loop automatically upon application pause and resume
             it as needed, which is done through the CotcGameObject as placed on your scene.
            
             </summary>
             <param name="domain">Domain to listen on. The `private` domain is used to receive system notifications
                 as well as messages sent by other players. Unless cross-game functionality is used, you
                 should start one loop on the private domain as soon as the gamer is signed in.</param>
             <returns>A domain event loop that is in started state.</returns>
        </member>
        <member name="M:CotcSdk.Gamer.#ctor(CotcSdk.Cloud,CotcSdk.Bundle)">
            <summary>Only instantiated internally.</summary>
            <param name="gamerData">Gamer data as returned by our API calls (loginanonymous, etc.).</param>
        </member>
        <member name="T:CotcSdk.GamerProfileMethods">
            @ingroup gamer_classes
            <summary>Exposes methods allowing to fetch and modify the profile of the signed in gamer.</summary>
        </member>
        <member name="M:CotcSdk.GamerProfileMethods.Get">
            <summary>
            Method used to retrieve some optional data of the logged in profile previously set by
            method SetProfile.
            </summary>
            <returns>Promise resolved when the operation has completed.</returns>
        </member>
        <member name="M:CotcSdk.GamerProfileMethods.Outline">
            <summary>
            Fetches an outline of the currently logged in user. Basically returns all available data about
            the user, including all domains he has been playing on. This can be used to avoid issuing
            multiple requests on startup (one for the profile, games, etc.).
            
            Non exhaustive list of fields include: `network`, `networkid`, `networksecret`, `registerTime`,
            `registerBy`, `games` (array), `profile`, `devices` (array), `domains` (array), `serverTime`.
            </summary>
            <returns>Promise resolved when the operation has completed with the resulting outline.</returns>
        </member>
        <member name="M:CotcSdk.GamerProfileMethods.Set(CotcSdk.Bundle)">
            <summary>
            Method used to associate some optional data to the logged in profile in a JSON dictionary.
            You can fill fields with keys "email", "displayName", "lang", "firstName", "lastName",
            "addr1", "addr2", "addr3" and "avatar". Other fields will be ignored. These fields must be
            strings, and some are pre-populated when the account is created, using the available info
            from the social network used to create the account.
            </summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="data">Is a Bundle holding the data to save for this user. The object can hold the
                whole profile or just a subset of the keys.</param>
        </member>
        <member name="T:CotcSdk.GamerTransactions">
            @ingroup gamer_classes
            <summary>
            Class allowing to manipulate the transactions and perform tasks related to achievements.
            This class is scoped by domain, meaning that you can call .Domain("yourdomain") and perform
            additional calls that are scoped.
            </summary>
        </member>
        <member name="M:CotcSdk.GamerTransactions.Balance">
            <summary>
            Retrieves the balance of the user. That is, the amount of "items" remaining after the various executed
            transactions.
            </summary>
            <returns>Promise resolved when the operation has completed. The attached bundle contains the balance.
                You can query the individual items by doing `result.Value["gold"]` for instance.</returns>
        </member>
        <member name="M:CotcSdk.GamerTransactions.Domain(System.String)">
            <summary>
            Changes the domain affected by the next operations.
            You should typically use it this way: `gamer.Transactions.Domain("private").Post(...);`
            </summary>
            <param name="domain">Domain on which to scope the transactions. Default to `private` if unmodified.</param>
            <returns>This object for operation chaining.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:CotcSdk.GamerTransactions.History(System.String,System.Int32,System.Int32)" -->
        <member name="M:CotcSdk.GamerTransactions.Post(CotcSdk.Bundle,System.String)">
            <summary>Executes a transaction on the behalf of the user.</summary>
            <returns>Promise resolved when the operation has completed. The attached result contains the new balance
                and the possibly triggered achievements.</returns>
            <param name="transaction">Transaction to run. Consists of keys and associated integer values. A negative value
                indicates that the associated balance should be decremented. The special value "-auto" resets the value
                to zero.</param>
            <param name="description">Description of the transaction. Will appear in the back office.</param>
        </member>
        <member name="T:CotcSdk.HttpRequestFailedHandler">
            @ingroup data_classes
            <summary>Delegate for failed HTTP requests. See Cloud.HttpRequestFailedHandler.</summary>
        </member>
        <member name="T:CotcSdk.HttpRequestFailedEventArgs">
            @ingroup data_classes
            <summary>
            This class is passed to the HttpRequestFailed handler as set on the Cloud.
            You need to do something with it, either call Abort or RetryIn else the http service will
            throw an exception.
            </summary>
        </member>
        <member name="P:CotcSdk.HttpRequestFailedEventArgs.Url">
            <summary>The original URL that the request failed to reach.</summary>
        </member>
        <member name="F:CotcSdk.HttpRequestFailedEventArgs.UserData">
            <summary>
            You can set this member from the handler; in case the request fails again, this data will be set
            to the same value as set last time. It is always set to null when the request fails for the first time.
            </summary>
        </member>
        <member name="M:CotcSdk.HttpRequestFailedEventArgs.Abort">
            <summary>Call this to abort the request. It won't be tried ever again.</summary>
        </member>
        <member name="M:CotcSdk.HttpRequestFailedEventArgs.RetryIn(System.Int32)">
            <summary>Call this to retry the request later.</summary>
            <param name="milliseconds">Time in which to try again. No other request will be executed during this time
                (they will be queued) as to respect the issuing order. Please keep this in mind when setting a
                high delay.</param>
        </member>
        <member name="T:CotcSdk.Match">
            @ingroup match_classes
            <summary>
            Represents a match with which you can interact through high level functionality.
            A match object is returned when you create a match, join it and so on.
            You should subscribe to ReceivedEvent right after you got this object.
            </summary>
        </member>
        <member name="P:CotcSdk.Match.Creator">
            <summary>Describes the creator of the match.</summary>
        </member>
        <member name="P:CotcSdk.Match.CustomProperties">
            <summary>Custom properties, as passed at the creation of the match.</summary>
        </member>
        <member name="P:CotcSdk.Match.Domain">
            <summary>The domain to which the match belongs (default is `private`).</summary>
        </member>
        <member name="P:CotcSdk.Match.Description">
            <summary>Description of the match, as defined by the user upon creation.</summary>
        </member>
        <member name="P:CotcSdk.Match.Gamer">
            <summary>Parent gamer object.</summary>
        </member>
        <member name="P:CotcSdk.Match.GlobalState">
            <summary>The global state of the game, which may be modified using a move.</summary>
        </member>
        <member name="P:CotcSdk.Match.IsCreator">
            <summary></summary>
            <returns>Whether you are the creator of the match, and as such have special privileges (like the ability
                to finish and delete a match).</returns>
        </member>
        <member name="P:CotcSdk.Match.LastEventId">
            <summary>The ID of the last event happened during this game; keep this for later, you might need it for some calls.</summary>
        </member>
        <member name="P:CotcSdk.Match.MatchId">
            <summary>The ID of the match. Keep this for later as it is useful to continue a match.</summary>
        </member>
        <member name="P:CotcSdk.Match.MaxPlayers">
            <summary>Maximum number of players, as passed.</summary>
        </member>
        <member name="P:CotcSdk.Match.Moves">
            <summary>List of existing events, which may be used to reproduce the state of the game.</summary>
        </member>
        <member name="E:CotcSdk.Match.OnMatchFinished">
            <summary>
            Event raised when the match is marked as finished. As with most match events, this event is
            delivered to all users currently participating to the match except the user who initiated it
            (that is, oneself).
            </summary>
        </member>
        <member name="E:CotcSdk.Match.OnPlayerJoined">
            <summary>Event raised when a player joins the match (excluding us obviously).</summary>
        </member>
        <member name="E:CotcSdk.Match.OnPlayerLeft">
            <summary>Event raised when a player leaves the match (excluding us obviously).</summary>
        </member>
        <member name="E:CotcSdk.Match.OnMovePosted">
            <summary>Event raised when a move is posted by any player except us in the match.</summary>
        </member>
        <member name="E:CotcSdk.Match.OnShoeDrawn">
            <summary>Event raised when an element is drawn from the shoe.</summary>
        </member>
        <member name="P:CotcSdk.Match.Players">
            <summary>IDs of players participating to the match, including the creator (which is reported alone there at creation).</summary>
        </member>
        <member name="P:CotcSdk.Match.Seed">
            <summary>
            A random seed that can be used to ensure consistent state across players of the game.
            This is a 31 bit number.
            </summary>
        </member>
        <member name="P:CotcSdk.Match.Status">
            <summary>The current state of the match (running, finished).</summary>
        </member>
        <member name="P:CotcSdk.Match.Shoe">
            <summary>
            An array of objects that are shuffled when the match starts. You can put anything you want inside and use
            it as values for your next game. This field is only returned when finishing a match.
            </summary>
        </member>
        <member name="M:CotcSdk.Match.DiscardEventHandlers">
            <summary>
            Clears all event handlers subscribed, ensuring that a match object can be dismissed without causing further
            actions in the background.
            </summary>
        </member>
        <member name="M:CotcSdk.Match.DrawFromShoe(System.Int32,CotcSdk.PushNotification)">
            <summary>Draws an item from the shoe.</summary>
            <returns>Promise resolved when the operation has completed. The attached bundle contains an array of items drawn
                from the shoe. You may do `(int)result.Value[0]` to fetch the first value as integer.</returns>
            <param name="count">The number of items to draw from the shoe.</param>
            <param name="notification">A notification that can be sent to all players currently playing the match (except you).</param>
        </member>
        <member name="M:CotcSdk.Match.Finish(System.Boolean,CotcSdk.PushNotification)">
            <summary>Terminates the match. You need to be the creator of the match to perform this operation.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="deleteToo">If true, deletes the match if it finishes successfully or is already finished.</param>
            <param name="notification">A notification that can be sent to all players currently playing the match (except you).</param>
        </member>
        <member name="M:CotcSdk.Match.InvitePlayer(System.String,CotcSdk.PushNotification)">
            <summary>
            Allows to invite a player to join a match. You need to be part of the match to send an invitation.
            This can be used to invite an opponent to a match that is not shown publicly.
            </summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="playerId">ID of the player to invite to the match. Player IDs can be found in the properties of the
                match (GamerInfo.GamerId).</param>
            <param name="notification">A push notification that can be sent to the invitee.</param>
        </member>
        <member name="M:CotcSdk.Match.Leave(CotcSdk.PushNotification)">
            <summary>Leaves the match.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="notification">A push notification that can be sent to all players except you.</param>
        </member>
        <member name="M:CotcSdk.Match.Lock(System.Action)">
            <summary>
            Protects the match against concurrent modification. Please look at the tutorial for more information on this
            subject. Basically, you should use it to protect your game state from race conditions.
            </summary>
        </member>
        <member name="M:CotcSdk.Match.PostMove(CotcSdk.Bundle,CotcSdk.Bundle,CotcSdk.PushNotification)">
            <summary>Posts a move to other players.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="moveData">A freeform object indicating the move data to be posted and transfered to other players. This
                move data will be kept in the events, and new players should be able to use it to reproduce the local game
                state.</param>
            <param name="updatedGameState">A freeform object replacing the global game state, to be used by players who join from
                now on. Passing a non null value clears the pending events in the match.</param>
            <param name="notification">A push notification that can be sent to all players except you.</param>
        </member>
        <member name="T:CotcSdk.MatchStatus">
            @ingroup match_classes
            <summary>Status of a match.</summary>
        </member>
        <member name="T:CotcSdk.MatchMove">
            @ingroup match_classes
            <summary>Represents a move in a match.</summary>
        </member>
        <member name="F:CotcSdk.MatchMove.MoveId">
            <summary>The data passed by the player when performing the move.</summary>
        </member>
        <member name="F:CotcSdk.MatchMove.MoveData">
            <summary>The data passed by the player when performing the move.</summary>
        </member>
        <member name="F:CotcSdk.MatchMove.PlayerId">
            <summary>The ID of the player who made the move.</summary>
        </member>
        <member name="T:CotcSdk.DrawnItemsResult">
            @ingroup model_classes
            <summary>Response resulting from a #CotcSdk.Match.DrawFromShoe call.</summary>
        </member>
        <member name="T:CotcSdk.MatchInfo">
            @ingroup model_classes
            <summary>
            Represents a basic match with less information associated than a real match.
            This is the kind of matches that you may find in sub-objects returned by some calls (list, etc.).
            </summary>
        </member>
        <member name="P:CotcSdk.MatchInfo.MatchId">
            <summary>The ID of the match.</summary>
        </member>
        <member name="M:CotcSdk.MatchInfo.DismissInvitation">
            <summary>Dismisses a pending invitation for the current user and the match. Fails if the user has not been invited.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
        </member>
        <member name="T:CotcSdk.AchievementType">
            @ingroup model_classes
            <summary>Type of achievement. The rules and the "Config" member of an AchievementDefinition depends on this.</summary>
        </member>
        <member name="T:CotcSdk.AchievementDefinition">
            @ingroup model_classes
            <summary>
            Definition of an achievement. Achievements are inputted on the backoffice and are triggered under
            defined circumstances.
            </summary>
        </member>
        <member name="T:CotcSdk.GamerOutline">
            @ingroup model_classes
            <summary>
            Outline information about a player.
            Can be enriched with information, accessible using the index operator [].
            Typically contains a profile field, with displayname, email and lang. You can fetch this by doing
            `string name = GamerOutline["profile"]["displayname"];`
            </summary>
        </member>
        <member name="T:CotcSdk.Done">
            @ingroup model_classes
            <summary>
            Generic result for an API call that has been successful and simply gives an indication of whether it was done properly or not.
            Usually the result should be true, but some operations may succeed and give an indication that nothing was done.
            You may use it as a boolean or get additional information by using it as a PropertiesObject.
            @code{.cs} Gamer.ChangeEmailAddress("a@localhost.localdomain").Then(done => {
            // Call was performed successfully, but the address might not have been changed.
            if (!done)
            throw new YourException("Address not changed");
            })
            .Catch(ex => {
            // Either the call has failed (ex is CotcException) or we caught YourException
            // because the call did nothing.
            }); @endcode
            </summary>
        </member>
        <member name="T:CotcSdk.SocialNetworkFriendResponse">
            @ingroup model_classes
            <summary>Wraps information about a list of friends coming from a social network.</summary>
        </member>
        <member name="T:CotcSdk.UserInfo">
            @ingroup model_classes
            <summary>
            Info about a user.
            Can be enriched with information, accessible using the index operator [].
            Typically contains a profile field, with displayname, email and lang. You can fetch this by doing
            `string name = UserInfo["profile"]["displayname"];`
            </summary>
        </member>
        <member name="P:CotcSdk.UserInfo.Network">
            <summary>Login network.</summary>
        </member>
        <member name="P:CotcSdk.UserInfo.NetworkId">
            <summary>Gamer credential. Use it to gain access to user related tasks.</summary>
        </member>
        <member name="P:CotcSdk.UserInfo.UserId">
            <summary>Id of the user (compatible with GamerId where used).</summary>
        </member>
        <member name="T:CotcSdk.GamerInfo">
            @ingroup model_classes
            <summary>
            Info about a player.
            Can be enriched with information, accessible using the index operator [].
            Typically contains a profile field, with displayname, email and lang. You can fetch this by doing
            `string name = GamerInfo["profile"]["displayName"];`
            </summary>
        </member>
        <member name="P:CotcSdk.GamerInfo.GamerId">
            <summary>Id of the gamer.</summary>
        </member>
        <member name="T:CotcSdk.GamerProfile">
            @ingroup model_classes
            <summary>
            Might contain the following:
            {
            "displayName" : "xxx",
            "email" : "xxx',
            "lang" : "en"
            }
            Usage: `string name = gamerProfile["displayName"];`.
            </summary>
        </member>
        <member name="T:CotcSdk.GamerProperties">
            @ingroup gamer_classes
            <summary>Allows to manipulate the gamer properties.</summary>
        </member>
        <member name="M:CotcSdk.GamerProperties.Domain(System.String)">
            <summary>
            Sets the domain affected by this object.
            You should typically use it this way: `gamer.Properties.Domain("private").Post(...);`
            </summary>
            <param name="domain">Optional domain on which to scope the properties. Default to `private` if unmodified.</param>
            <returns>This object for operation chaining.</returns>
        </member>
        <member name="M:CotcSdk.GamerProperties.GetKey(System.String)">
            <summary>Retrieves an individual key from the gamer properties.</summary>
            <returns>Promise resolved when the operation has completed. The attached bundle contains the fetched property.
                As usual with bundles, it can be casted to the proper type you are expecting.
                In case the call fails, the bundle is not attached, the call is marked as failed with a 404 status.</returns>
            <param name="key">The name of the key to be fetched.</param>
        </member>
        <member name="M:CotcSdk.GamerProperties.GetAll">
            <summary>Retrieves all the properties of the gamer.</summary>
            <returns>Promise resolved when the operation has completed. The attached bundle contains the keys along with their
                values. If you would like to fetch the value of a given key and you expect it to be a string, you may simply
                do `string value = result.Value["key"];`. Bundle handles automatic conversions as well, so if you passed an
                integer, you may as well fetch it as a string and vice versa.</returns>
        </member>
        <member name="M:CotcSdk.GamerProperties.SetKey(System.String,CotcSdk.Bundle)">
            <summary>Sets a single key from the user properties.</summary>
            <returns>Promise resolved when the operation has completed. The enclosed value indicates success.</returns>
            <param name="key">The name of the key to set the value for.</param>
            <param name="value">The value to set. As usual with bundles, casting is implicitly done, so you may as well
                call this method passing an integer or string as value for instance.</param>
        </member>
        <member name="M:CotcSdk.GamerProperties.SetAll(CotcSdk.Bundle)">
            <summary>Sets all keys at once.</summary>
            <returns>Promise resolved when the operation has completed. The enclosed value indicates success.</returns>
            <param name="properties">A bundle of key/value properties to set. An example is `Bundle.CreateObject("key", "value")`.</param>
        </member>
        <member name="M:CotcSdk.GamerProperties.RemoveKey(System.String)">
            <summary>Removes a single key from the user properties.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="key">The name of the key to remove.</param>
        </member>
        <member name="M:CotcSdk.GamerProperties.RemoveAll">
            <summary>Remove all properties for the user.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
        </member>
        <member name="T:CotcSdk.IndexResult">
            @ingroup model_classes
            <summary>
            Result of an index query. Represents a single returned object.
            This object is a #CotcSdk.PropertiesObject, meaning that additional properties can be queried. If you want to
            check what is returned as a JSON object, simply log `this.ToString()`.
            </summary>
        </member>
        <member name="P:CotcSdk.IndexResult.IndexName">
            <summary>The name of the index.</summary>
        </member>
        <member name="P:CotcSdk.IndexResult.ObjectId">
            <summary>The ID of the returned object, as passed when indexing the object.</summary>
        </member>
        <member name="P:CotcSdk.IndexResult.Payload">
            <summary>Document payload; passed upon indexing the object.</summary>
        </member>
        <member name="P:CotcSdk.IndexResult.Properties">
            <summary>Indexed properties. Passed upon indexing the object.</summary>
        </member>
        <member name="P:CotcSdk.IndexResult.ResultScore">
            <summary>Score (elastic search term) of the document.</summary>
        </member>
        <member name="T:CotcSdk.IndexSearchResult">
            @ingroup model_classes
            <summary>Contains the results of a search on the index.</summary>
        </member>
        <member name="P:CotcSdk.IndexSearchResult.Hits">
            <summary>Paginated list of results.0</summary>
        </member>
        <member name="F:CotcSdk.IndexSearchResult.MaxScore">
            <summary>Maximum score in the results.</summary>
        </member>
        <member name="T:CotcSdk.LoginNetwork">
            @ingroup model_classes
            <summary>Social network used for identification / signing in.</summary>
        </member>
        <member name="T:CotcSdk.LoginNetworkExtensions">
            @ingroup model_classes
            <summary>You can call LoginNetwork.Describe() to stringify the login network and pass it to various APIs.</summary>
        </member>
        <member name="T:CotcSdk.MatchEvent">
            @ingroup match_classes
            <summary>Basis for a match event. An event is actually always one of the subclasses (Match*Event).</summary>
        </member>
        <member name="P:CotcSdk.MatchEvent.MatchEventId">
            <summary>The unique ID of the event. Might match the last event ID of an existing match.</summary>
        </member>
        <member name="T:CotcSdk.MatchJoinEvent">
            @ingroup match_classes
            <summary>
            Event of type match.join.
            Broadcasted when a player joins a match. The joining player himself doesn't receive the event.
            </summary>
        </member>
        <member name="F:CotcSdk.MatchJoinEvent.PlayersJoined">
            <summary>The list of players who just joined the match.</summary>
        </member>
        <member name="T:CotcSdk.MatchLeaveEvent">
            @ingroup match_classes
            <summary>
            Event of type match.leave.
            Broadcasted when a player leaves the match. The leaving player himself doesn't receive the event.
            </summary>
        </member>
        <member name="F:CotcSdk.MatchLeaveEvent.PlayersLeft">
            <summary>The list of players who just joined the match.</summary>
        </member>
        <member name="T:CotcSdk.MatchFinishEvent">
            @ingroup match_classes
            <summary>
            Event of type match.finish.
            Broadcasted to all participants except the one who initiated the request when a match is finished.
            </summary>
        </member>
        <member name="F:CotcSdk.MatchFinishEvent.Finished">
            <summary>Whether the match has been finished.</summary>
        </member>
        <member name="T:CotcSdk.MatchMoveEvent">
            @ingroup match_classes
            <summary>
            Event of type match.move.
            Broadcasted when a player makes a move. The player himself doesn't receive the event.
            </summary>
        </member>
        <member name="F:CotcSdk.MatchMoveEvent.Id">
            <summary>The ID of the move.</summary>
        </member>
        <member name="F:CotcSdk.MatchMoveEvent.MoveData">
            <summary>The data passed by the player when performing the move.</summary>
        </member>
        <member name="F:CotcSdk.MatchMoveEvent.PlayerId">
            <summary>The ID of the player who made the move.</summary>
        </member>
        <member name="T:CotcSdk.MatchShoeDrawnEvent">
            @ingroup match_classes
            <summary>
            Event of type match.shoedraw.
            Broadcasted when a player draws items from the shoe. The player himself does not receive the event.
            </summary>
        </member>
        <member name="F:CotcSdk.MatchShoeDrawnEvent.Count">
            <summary>Number of items that were drawn.</summary>
        </member>
        <member name="T:CotcSdk.MatchInviteEvent">
            @ingroup match_classes
            <summary>
            Event of type match.invite.
            Received by another player when someone invites him to the match.
            </summary>
        </member>
        <member name="F:CotcSdk.MatchInviteEvent.Inviter">
            <summary>Information about the player who sent the invitation.</summary>
        </member>
        <member name="T:CotcSdk.MatchListResult">
            @ingroup model_classes
            <summary>Entry within a list of matches.</summary>
        </member>
        <member name="P:CotcSdk.MatchListResult.Creator">
            <summary>Describes the creator of the match.</summary>
        </member>
        <member name="P:CotcSdk.MatchListResult.CustomProperties">
            <summary>Custom properties, as passed at the creation of the match.</summary>
        </member>
        <member name="P:CotcSdk.MatchListResult.Description">
            <summary>Description of the match, as defined by the user upon creation.</summary>
        </member>
        <member name="P:CotcSdk.MatchListResult.MatchId">
            <summary>The ID of the match. Keep this for later as it is useful to continue a match.</summary>
        </member>
        <member name="P:CotcSdk.MatchListResult.MaxPlayers">
            <summary>Maximum number of players, as passed.</summary>
        </member>
        <member name="P:CotcSdk.MatchListResult.Status">
            <summary>The current state of the match (running, finished).</summary>
        </member>
        <member name="T:CotcSdk.PostedGameScore">
            @ingroup model_classes
            <summary>Result of posting a score.</summary>
        </member>
        <member name="P:CotcSdk.PostedGameScore.HasBeenSaved">
            <summary>Whether the score was saved. This can be set to false if the score is not as good as a previous best for the player.</summary>
        </member>
        <member name="P:CotcSdk.PostedGameScore.Rank">
            <summary>The rank of the gamer in the leaderboard after posting this score.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:CotcSdk.PropertiesObject" -->
        <member name="P:CotcSdk.PropertiesObject.Item(System.String)">
            <summary>Allows to query additional properties via an indexer (can be enriched via hooks).</summary>
        </member>
        <member name="M:CotcSdk.PropertiesObject.AsBundle">
            <summary>
            Gets the underlying Bundle. Dangerous, only use internally, when you want to put the contents
            of a properties object into an existing bundle.
            </summary>
        </member>
        <member name="M:CotcSdk.PropertiesObject.Keys">
            <summary>Allows to browse all keys (might include some that are already exposed as typed properties in the object).</summary>
            <returns>The list of keys.</returns>
        </member>
        <member name="M:CotcSdk.PropertiesObject.GetEnumerator">
            <summary>Allows to browse all keys (might include some that are already exposed as typed properties in the object).</summary>
            <returns>An enumerator that allows to browse all key-value pairs. The values are #CotcSdk.Bundle, on which you can
                perform all the usual conversions, such as casting it as a string if the property is expected to be a
                string for instance.</returns>
        </member>
        <member name="M:CotcSdk.PropertiesObject.ToString">
            <summary>You may use this to debug what is inside this property object.</summary>
            <returns>A JSON string representing the object.</returns>
        </member>
        <member name="M:CotcSdk.PropertiesObject.ToJson">
            <summary>Builds a JSON representation of this object, same as ToString actually.</summary>
            <returns>A JSON string representing the object.</returns>
        </member>
        <member name="T:CotcSdk.PushNotification">
            @ingroup data_classes
            <summary>
            Push notifications can be specified in some API calls to push an OS push notification to inactive users.
            It is typically a JSON with made of attributes which represent language -> message pairs.
            Here is an example: `new PushNotification().Message("en", "Help me!").Message("fr", "Aidez moi!")`.
            </summary>
        </member>
        <member name="M:CotcSdk.PushNotification.#ctor">
            <summary>Creates a PushNotification object.</summary>
            <returns>A new PushNotification object.</returns>
        </member>
        <member name="M:CotcSdk.PushNotification.#ctor(System.String,System.String)">
            <summary>Creates a PushNotification object with one language/text pair which will be put in the object initially.</summary>
            <returns>A new bundle filled with one language/text pair.</returns>
        </member>
        <member name="M:CotcSdk.PushNotification.#ctor(System.String,System.String,System.String,System.String)">
            <summary>Creates a PushNotification object with two language/text pairs which will be put in the object initially.</summary>
            <returns>A new bundle filled with two language/text pairs.</returns>
        </member>
        <member name="M:CotcSdk.PushNotification.#ctor(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Creates a PushNotification object with three language/text pairs which will be put in the object initially.</summary>
            <returns>A new bundle filled with three language/text pairs.</returns>
        </member>
        <member name="M:CotcSdk.PushNotification.#ctor(System.Collections.Generic.KeyValuePair{System.String,System.String}[])">
            <summary>Creates a PushNotification object with many language/text pairs which will be put in the object initially.</summary>
            <returns>A new bundle filled with many language/text pairs.</returns>
        </member>
        <member name="M:CotcSdk.PushNotification.Message(System.String,System.String)">
            <summary>Adds or replaces a string for a given language.</summary>
            <param name="language">Language code, ex. "en", "ja", etc.</param>
            <param name="text">The text for this language.</param>
        </member>
        <member name="T:CotcSdk.Score">
            @ingroup model_classes
            <summary>Represents a score fetched from a leaderboard.</summary>
        </member>
        <member name="P:CotcSdk.Score.GamerInfo">
            <summary>
            Info about the gamer who posted the score.
            This information may not be present for some calls (calls scoped to the current user) and the member be null.
            Please read the documentation to find out which calls apply this policy.
            </summary>
        </member>
        <member name="P:CotcSdk.Score.Info">
            <summary>Info about the score (passed when posted).</summary>
        </member>
        <member name="P:CotcSdk.Score.PostedAt">
            <summary>Time at which the score was processed by the server (posted).</summary>
        </member>
        <member name="P:CotcSdk.Score.Rank">
            <summary>One-based rank of this score on the board.</summary>
        </member>
        <member name="P:CotcSdk.Score.Value">
            <summary>Actual score value.</summary>
        </member>
        <member name="T:CotcSdk.SocialNetworkFriend">
            @ingroup model_classes
            <summary>
            Data about a friend on the social network.
            The most important field is the id, which allows to recognize the gamer uniquely among the given social network.
            </summary>
        </member>
        <member name="F:CotcSdk.SocialNetworkFriend.Id">
            <summary>Required. The ID given by the social network, allowing to uniquely identify the friend in question.</summary>
        </member>
        <member name="F:CotcSdk.SocialNetworkFriend.FirstName">
            <summary>
            If you have either a name (composite of name/first name regardless of order), either the two components
            (name, first name), pass them here. You should pass at least one of these.
            </summary>
        </member>
        <member name="F:CotcSdk.SocialNetworkFriend.LastName">
            <summary>
            If you have either a name (composite of name/first name regardless of order), either the two components
            (name, first name), pass them here. You should pass at least one of these.
            </summary>
        </member>
        <member name="F:CotcSdk.SocialNetworkFriend.Name">
            <summary>
            If you have either a name (composite of name/first name regardless of order), either the two components
            (name, first name), pass them here. You should pass at least one of these.
            </summary>
        </member>
        <member name="P:CotcSdk.SocialNetworkFriend.ClanInfo">
            <summary>
            Additional info that might have been enriched by the CotC servers.
            You should never guess or create this info by yourself.
            </summary>
        </member>
        <member name="M:CotcSdk.SocialNetworkFriend.#ctor(System.String,System.String,System.String,System.String)">
            <summary>User constructor.</summary>
        </member>
        <member name="M:CotcSdk.SocialNetworkFriend.#ctor">
            <summary>Default constructor for convenience.</summary>
        </member>
        <member name="M:CotcSdk.SocialNetworkFriend.#ctor(CotcSdk.Bundle)">
            <summary>Build from existing JSON data.</summary>
        </member>
        <member name="T:CotcSdk.Transaction">
            @ingroup model_classes
            <summary>Transaction as archived on the CotC servers.</summary>
        </member>
        <member name="F:CotcSdk.Transaction.TxData">
            <summary>The transaction itself (e.g. {"gold": 100}).</summary>
        </member>
        <member name="T:CotcSdk.TransactionResult">
            @ingroup model_classes
            <summary>
            Result of a transaction call. Contains the new balance (after the transaction has been
            executed atomically) and the list of triggered achievements.
            </summary>
        </member>
        <member name="T:CotcSdk.CotcException">
            @ingroup main_classes
            <summary>
            Standard type of exceptions as forwarded most of the time in case of API error (network included).
            </summary>
        </member>
        <member name="M:CotcSdk.CotcException.#ctor(CotcSdk.ErrorCode,System.String)">
            <summary>To be used for an higher level error. No information about the HTTP request would be attached.</summary>
        </member>
        <member name="M:CotcSdk.CotcException.#ctor(CotcSdk.HttpResponse,System.String)">
            <summary>To be used when an HTTP request has failed. Will extract a default error code (server error, network error) from the HTTP request.</summary>
        </member>
        <member name="T:CotcSdk.GamerVfs">
            @ingroup gamer_classes
            <summary>
            Represents a key/value system, also known as virtual file system.
            This class is scoped by domain, meaning that you can call .Domain("yourdomain") and perform
            additional calls that are scoped.
            </summary>
        </member>
        <member name="M:CotcSdk.GamerVfs.Domain(System.String)">
            <summary>
            Sets the domain affected by this object.
            You should typically use it this way: `gamer.GamerVfs.Domain("private").SetKey(...);`
            </summary>
            <param name="domain">Domain on which to scope the VFS. Defaults to `private` if not specified.</param>
            <returns>This object for operation chaining.</returns>
        </member>
        <member name="M:CotcSdk.GamerVfs.GetKey(System.String)">
            <summary>Retrieves an individual key from the key/value system.</summary>
            <returns>Promise resolved when the operation has completed. The attached bundle contains the fetched
                property. As usual with bundles, it can be casted to the proper type you are expecting.
                If the property doesn't exist, the call is marked as failed with a 404 status.</returns>
            <param name="key">The name of the key to be fetched.</param>
            <remarks>This method is obsolete, use GetValue instead.</remarks>
        </member>
        <member name="M:CotcSdk.GamerVfs.GetValue(System.String)">
            <summary>Retrieves an individual key or all keys from the key/value system.</summary>
            <returns>Promise resolved when the operation has completed. The attached bundle contains the fetched
                property(ies) in the "result" key. As usual with bundles, it can be casted to the proper type you
                are expecting. If the property doesn't exist, the call is marked as failed with a 404 status.</returns>
            <param name="key">The name of the key to be fetched. If you don't pass any key, then all the keys
                will be returned in a global JSON</param>
        </member>
        <member name="M:CotcSdk.GamerVfs.GetKeyBinary(System.String)">
            <summary>Retrieves the binary data of an individual key from the key/value system.</summary>
            <returns>Promise resolved when the operation has completed. The binary data is attached as the value
                of the result. Please ensure that the key was set with binary data before, or this call will
                fail with a network error.</returns>
            <param name="key">The name of the key to be fetched.</param>
            <remarks>This method is obsolete, use GetBinary instead.</remarks>
        </member>
        <member name="M:CotcSdk.GamerVfs.GetBinary(System.String)">
            <summary>Retrieves the binary data of an individual key from the key/value system.</summary>
            <returns>Promise resolved when the operation has completed. The binary data is attached as the value
                of the result. Please ensure that the key was set with binary data before, or this call will
                fail with a network error.</returns>
            <param name="key">The name of the key to be fetched.</param>
        </member>
        <member name="M:CotcSdk.GamerVfs.SetKey(System.String,CotcSdk.Bundle)">
            <summary>Sets the value of a key in the key/value system.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="key">The name of the key to set the value for.</param>
            <param name="value">The value to set. As usual with bundles, casting is implicitly done, so you may as well
                call this method passing an integer or string as value for instance.</param>
            <remarks>This method is obsolete, use SetValue instead.</remarks>
        </member>
        <member name="M:CotcSdk.GamerVfs.SetValue(System.String,CotcSdk.Bundle)">
            <summary>Sets the value of a single key or all keys in the key/value system.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="key">The name of the key to set the value for.</param>
            <param name="value">The value to set. As usual with bundles, casting is implicitly done, so you may as well
                call this method passing an integer or string as value for instance.</param>
        </member>
        <member name="M:CotcSdk.GamerVfs.SetKeyBinary(System.String,System.Byte[])">
            <summary>Sets the value of a key in the key/value system as binary data.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="key">The name of the key to set the value for.</param>
            <param name="binaryData">The value to set as binary data.</param>
            <remarks>This method is obsolete, use SetBinary instead.</remarks>
        </member>
        <member name="M:CotcSdk.GamerVfs.SetBinary(System.String,System.Byte[])">
            <summary>Sets the value of a key in the key/value system as binary data.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="key">The name of the key to set the value for.</param>
            <param name="binaryData">The value to set as binary data.</param>
        </member>
        <member name="M:CotcSdk.GamerVfs.RemoveKey(System.String)">
            <summary>Removes a single key from the key/value system.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="key">The name of the key to remove.</param>
            <remarks>This method is obsolete, use DeleteValue instead.</remarks>
        </member>
        <member name="M:CotcSdk.GamerVfs.DeleteValue(System.String)">
            <summary>Removes a single key or all keys from the key/value system.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="key">The name of the key to remove. Beware, if you don't pass any key at all,
                then ALL the key/value will be removed. Should be used with care!</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:CotcSdk.NonpagedList`1" -->
        <member name="T:CotcSdk.PagedList`1">
            @ingroup main_classes
            <summary>Represents a paginated list, which allows for easy navigation through multiple results.</summary>
        </member>
        <member name="M:CotcSdk.PagedList`1.FetchNext">
            <summary>Fetches the next results and calls the same handler again.</summary>
        </member>
        <member name="M:CotcSdk.PagedList`1.FetchPrevious">
            <summary>Fetches the previous results and calls the same handler again.</summary>
        </member>
        <member name="P:CotcSdk.PagedList`1.HasPrevious">
            <summary></summary>
            <returns>Whether there is a previous page. Call FetchPrevious to go back to it.</returns>
        </member>
        <member name="P:CotcSdk.PagedList`1.HasNext">
            <summary></summary>
            <returns>Whether there is a next page. Call FetchNext to go back to it.</returns>
        </member>
        <member name="F:CotcSdk.PagedList`1.Offset">
            <summary></summary>
            <returns>The number of the first result in the list.</returns>
        </member>
        <member name="F:CotcSdk.PagedList`1.Total">
            <summary></summary>
            <returns>The total number of items (possibly greater than the page size).</returns>
        </member>
        <member name="T:CotcSdk.Promise`1">
            @ingroup main_classes
            <summary>
            %Promise of future result, which may fail or succeed. Returned as a result of any asnychronous operation.
            
            Complies to the standard %Promise specification: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise
            
            Used throughout most API calls to ease the manipulation of asynchronous methods. See [this chapter](#getting_started_ref) for a
            tutorial on how to use promises with the SDK.
            </summary>
            <typeparam name="PromisedT">Expected result type (in case of success, else an exception is returned).</typeparam>
        </member>
        <member name="M:CotcSdk.Promise`1.Catch(System.Action{System.Exception})">
            <summary>Catches a failure at that point in the chain.</summary>
            <param name="onRejected">Block handling the exception.</param>
            <returns>Another promise which is rejected under any circumstances: either for the same reason as this one (if
            the promise is caught further in the chain and this block executes well) or with another exception (if the
            onRejected block throws an exception). As such, it is highly recommended to provide a .Done() block after your
            Catch block, so that any exception in the catch body can be propagated to the unhandled exception handler.</returns>
        </member>
        <member name="M:CotcSdk.Promise`1.Done(System.Action{`0},System.Action{System.Exception})">
            <summary>Put this at the end of a promise chain. It ensures that unhandled exceptions can be delivered properly.</summary>
            <param name="onResolved">Execute upon success of all the chain steps.</param>
            <param name="onRejected">Execute upon rejection of the promise chain (any failure within the chain).</param>
        </member>
        <member name="M:CotcSdk.Promise`1.Done(System.Action{`0})">
            <summary>Put this at the end of a promise chain.</summary>
            <param name="onResolved">Execute upon success (as is, this is nearly equivalent to providing a simple Then block, except
            that you can not do further chain the promise. Therefore, it ensures that an exception not handled at that point will never
            be and allows unhandled exceptions to be delivered properly.</param>
        </member>
        <member name="M:CotcSdk.Promise`1.Done">
            <summary>Put this at the end of a promise chain. It ensures that unhandled exceptions can be delivered properly.</summary>
        </member>
        <member name="M:CotcSdk.Promise`1.Reject(System.Exception)">
            <summary>Reject this promise (indicate that the process failed for some reason).</summary>
            <param name="ex">Exception to return as the failure result.</param>
        </member>
        <member name="M:CotcSdk.Promise`1.Rejected(System.Exception)">
            <summary>Shorthand to create a promise that is already rejected.</summary>
            <param name="ex">Exception to reject the promise with.</param>
            <returns>A promise that is rejected right away.</returns>
        </member>
        <member name="M:CotcSdk.Promise`1.Resolve(`0)">
            <summary>Resolves the promise, i.e. notifies a successful result of the async operation.</summary>
            <param name="value">Result of the async operation. Caught by subscribers to this promise via a Then block.</param>
        </member>
        <member name="M:CotcSdk.Promise`1.Then``1(System.Func{`0,CotcSdk.Promise{``0}})">
            <summary>
            Add a resolved callback and a rejected callback.
            The resolved callback chains a value promise (optionally converting to a different value type).
            </summary>
            <typeparam name="ConvertedT">Type of the expected result (it should be guessed automatically).</typeparam>
            <param name="onResolved">Executed upon successful result.</param>
            <returns>A new promise from another type.</returns>
        </member>
        <member name="M:CotcSdk.Promise`1.Then(System.Action{`0})">
            <summary>
            Registers a block of code to be executed when the promise returns a successful result.
            </summary>
            <param name="onResolved">Executed upon successful result.</param>
            <returns>A new promise to be used for chaining (you can Catch an exception that happened in the block for
            instance.</returns>
        </member>
        <member name="M:CotcSdk.Promise`1.Then(System.Action{`0},System.Action{System.Exception})">
            <summary>
            Add a resolved callback and a rejected callback.
            The resolved callback chains a non-value promise.
            </summary>
            <param name="onResolved">Executed upon successful result.</param>
            <param name="onRejected">Executed upon failure (promise rejected).</param>
            <returns>A promise that can be further chained.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:CotcSdk.Promise`1.Then``1(System.Func{`0,CotcSdk.Promise{``0}},System.Action{System.Exception})" -->
        <member name="E:CotcSdk.Promise.UnhandledException">
            <summary>
            Event raised for unhandled errors.
            For this to work you have to complete your promises with a call to Done().
            </summary>
        </member>
        <member name="F:CotcSdk.Promise.Debug_OutputAllExceptions">
            <summary>
            Set this to true in order to output any exception to the console, even if it is caught by a .Catch block.
            Just a helper, never keep it true in production.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:CotcSdk.Bundle" -->
        <member name="T:CotcSdk.Bundle.DataType">
            <summary>Possible types of data storable into a bundle.</summary>
        </member>
        <member name="M:CotcSdk.Bundle.CreateObject">
            <summary>Creates a bundle of type object.</summary>
            <returns>A new bundle.</returns>
        </member>
        <member name="M:CotcSdk.Bundle.CreateObject(System.String,CotcSdk.Bundle)">
            <summary>Creates a bundle of type object with one key/value pair which will be put in the object initially.</summary>
            <returns>A new bundle filled with one key/value pair.</returns>
        </member>
        <member name="M:CotcSdk.Bundle.CreateObject(System.String,CotcSdk.Bundle,System.String,CotcSdk.Bundle)">
            <summary>Creates a bundle of type object with two key/value pairs which will be put in the object initially.</summary>
            <returns>A new bundle filled with two key/value pairs.</returns>
        </member>
        <member name="M:CotcSdk.Bundle.CreateObject(System.String,CotcSdk.Bundle,System.String,CotcSdk.Bundle,System.String,CotcSdk.Bundle)">
            <summary>Creates a bundle of type object with three key/value pairs which will be put in the object initially.</summary>
            <returns>A new bundle filled with three key/value pairs.</returns>
        </member>
        <member name="M:CotcSdk.Bundle.CreateObject(System.Collections.Generic.KeyValuePair{System.String,CotcSdk.Bundle}[])">
            <summary>Creates a bundle of type object with many key/value pairs which will be put in the object initially.</summary>
            <returns>A new bundle filled with many key/value pairs.</returns>
        </member>
        <member name="M:CotcSdk.Bundle.CreateArray(CotcSdk.Bundle[])">
            <summary>Creates a bundle of type array.</summary>
            <param name="values">Optional values to pre-fill the array with. Since bundle are implicitly converted, remember
            that you may pass an integer, string, etc.</param>
            <returns>A new bundle.</returns>
        </member>
        <member name="F:CotcSdk.Bundle.Empty">
            <summary>Empty (null-like) Bundle. See class documentation for more information.</summary>
        </member>
        <member name="M:CotcSdk.Bundle.Clone">
            <summary>Deep copies the bundle.</summary>
        </member>
        <member name="P:CotcSdk.Bundle.Parent">
            <summary>Returns the parent of this bundle, if it was detached from any tree. May be null
            if it is the root or has never been attached.</summary>
        </member>
        <member name="P:CotcSdk.Bundle.Root">
            <summary>Returns the root of this tree. Goes as far as possible back in the hierarchy.</summary>
        </member>
        <member name="T:CotcSdk.EmptyBundle">
            <summary>Never instantiate this class. Use Bundle.Empty instead. Pass that everywhere an explicit configuration is not wanted.</summary>
        </member>
        <member name="T:CotcSdk.CotcSettings">
            @cond private 
        </member>
        <member name="F:CotcSdk.HttpRequest.DoNotEnqueue">
            <summary>Set to perform the request immediately, regardless of a request already being run.</summary>
        </member>
        <member name="F:CotcSdk.HttpRequest.Method">
            <summary>When not set (null), uses GET if no body is provided, or POST otherwise.</summary>
        </member>
        <member name="P:CotcSdk.HttpResponse.HasFailed">
            <summary>
            If true, means that the request has completely failed, not that it received an error code such as 400.
            This will appear as completely normal. Use Common.HasFailed in that case.
            </summary>
        </member>
        <member name="M:CotcSdk.HttpResponse.ShouldBeRetried(CotcSdk.HttpRequest)">
            <summary>Returns whether this response is in an error state that should be retried according to the request configuration.</summary>
        </member>
        <member name="T:CotcSdk.HttpClient">
            Base for an HTTP client. Handles many useful things (timeout, calculating the URL, altering the load balancer).
        </member>
        <member name="T:CotcSdk.HttpClient.WebRequest">
            <summary>Asynchronous request state.</summary>
        </member>
        <member name="M:CotcSdk.HttpClient.EnqueueRequest(CotcSdk.HttpRequest)">
            <summary>Enqueues a request to make it processed asynchronously. Will potentially wait for the other requests enqueued to finish.</summary>
        </member>
        <member name="M:CotcSdk.HttpClient.FinishWithRequest(CotcSdk.HttpClient.WebRequest,CotcSdk.HttpResponse)">
            <summary>Called after an HTTP request has been processed in any way (error or failure). Decides what to do next.</summary>
        </member>
        <member name="M:CotcSdk.HttpClient.ProcessRequest(CotcSdk.HttpRequest,System.Object)">
            <summary>Processes a single request asynchronously. Will continue to FinishWithRequest in some way.</summary>
        </member>
        <member name="M:CotcSdk.HttpClient.TimeoutCallback(System.Object)">
            <summary>Called upon timeout.</summary>
        </member>
        <member name="T:CotcSdk.LogLevel">
            <summary>Possible logging levels to be set.</summary>
        </member>
        <member name="P:CotcSdk.Managers.HttpClient">
            <summary>
            Designates the HTTP default client, as selected by the user (by calling SetHttpClientType, or
            publicly via the CotC game object settings or Cloud Setup).
            </summary>
        </member>
        <member name="P:CotcSdk.Managers.UnityHttpClient">
            <summary>Allows to specifically direct a request to the Unity HTTP Client, while using the
            default client for other requests. (The two can run in parallel).</summary>
        </member>
        <member name="M:CotcSdk.Managers.SetHttpClientParams(System.Int32,System.Boolean)">
            <summary>Defines the type of HTTP client./// </summary>
            <param name="type">0 = HttpWebRequest, 1 = UnityWebRequest.</param>
            <param name="verboseMode">true to enable verbose logging of every request, false otherwise.</param>
        </member>
        <member name="T:CotcSdk.UnityHttpClientV2">
            Better HTTP client based on UnityEngine.Networking.UnityWebRequest.
        </member>
        <member name="T:CotcSdk.UnityHttpClientV2.UnityRequest">
            <summary>Asynchronous request state.</summary>
        </member>
        <member name="M:CotcSdk.UnityHttpClientV2.UnityRequest.LogRequest">
            <summary>Prints the current request for user convenience.</summary>
        </member>
        <member name="M:CotcSdk.UnityHttpClientV2.UnityRequest.LogResponse(CotcSdk.HttpResponse)">
            <summary>Prints information about the response for debugging purposes.</summary>
        </member>
        <member name="T:CotcSdk.MonoHttpClient">
            Former Unity HTTP client, based on the standard .NET framework classes (HttpWebRequest).
            
            Since this class is not really supported (compared to the WWW class which is supposed to be the standard
            but unsufficient), it causes a lot of problems on some platforms and we're happy to get rid of it.
        </member>
        <member name="T:CotcSdk.MonoHttpClient.RequestState">
            <summary>Asynchronous request state.</summary>
        </member>
        <member name="M:CotcSdk.MonoHttpClient.RequestState.LogRequest">
            <summary>Prints the current request for user convenience.</summary>
        </member>
        <member name="M:CotcSdk.MonoHttpClient.RequestState.LogResponse(CotcSdk.HttpResponse)">
            <summary>Prints information about the response for debugging purposes.</summary>
        </member>
        <member name="M:CotcSdk.MonoHttpClient.GetRequestStreamCallback(System.IAsyncResult)">
            <summary>Got a network stream to write to.</summary>
        </member>
        <member name="M:CotcSdk.MonoHttpClient.RespCallback(System.IAsyncResult)">
            <summary>Called when a response has been received by the HttpWebRequest.</summary>
        </member>
        <member name="M:CotcSdk.MonoHttpClient.ReadCallBack(System.IAsyncResult)">
            <summary>Reads the response buffer little by little.</summary>
        </member>
        <member name="T:CotcSdk.ConfiguredProduct">
            @ingroup model_classes
            <summary>Information about a configured product on the BO.</summary>
        </member>
        <member name="P:CotcSdk.ConfiguredProduct.ProductId">
            <summary>The product identifier as formatted in the query.</summary>
        </member>
        <member name="P:CotcSdk.ConfiguredProduct.AppStoreId">
            <summary>ID of the product on the App Store (mapping with ProductId on CotC).</summary>
        </member>
        <member name="P:CotcSdk.ConfiguredProduct.MacAppStoreId">
            <summary>ID of the product on the Mac App Store (mapping with ProductId on CotC).</summary>
        </member>
        <member name="P:CotcSdk.ConfiguredProduct.GooglePlayId">
            <summary>ID of the product on the Google Play Store (mapping with ProductId on CotC).</summary>
        </member>
        <member name="T:CotcSdk.PurchaseTransaction">
            @ingroup model_classes
            <summary>Information about a purchased product transaction.</summary>
        </member>
        <member name="P:CotcSdk.PurchaseTransaction.Store">
            <summary>The type of Store on which the purchase has been made.</summary>
        </member>
        <member name="P:CotcSdk.PurchaseTransaction.ProductId">
            <summary>The ID of the product purchased.</summary>
        </member>
        <member name="P:CotcSdk.PurchaseTransaction.PurchaseDate">
            <summary>Time of purchase.</summary>
        </member>
        <member name="P:CotcSdk.PurchaseTransaction.Price">
            <summary>The price paid (the price might have been changed since then on iTunes Connect; any such change does not reflect here).</summary>
        </member>
        <member name="P:CotcSdk.PurchaseTransaction.Currency">
            <summary>Currency unit of the price paid.</summary>
        </member>
        <member name="P:CotcSdk.PurchaseTransaction.StoreTransactionId">
            <summary>The ID of transaction on the original store. You might want to use it for customer service. Depends on the store type.</summary>
        </member>
        <member name="T:CotcSdk.StoreType">
            @ingroup model_classes
            <summary>Type of store in which products are purchased.</summary>
        </member>
        <member name="T:CotcSdk.ValidateReceiptResult">
            @ingroup model_classes
            <summary>Result of #CotcSdk.GamerStore.ValidateReceipt.</summary>
        </member>
        <member name="T:CotcSdk.GamerAccountMethods">
            @ingroup gamer_classes
            <summary>API functions acting on an user account (convert, etc.).</summary>
        </member>
        <member name="M:CotcSdk.GamerAccountMethods.ChangeEmailAddress(System.String)">
            <summary>Changes the e-mail address of the current user. Works for e-mail type accounts.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="newEmailAddress">The new e-mail address to be used for signing in.</param>
        </member>
        <member name="M:CotcSdk.GamerAccountMethods.ChangePassword(System.String)">
            <summary>Changes the password of the current user. Works for e-mail type accounts.</summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="newPassword">The new password to be used for signing in.</param>
        </member>
        <member name="M:CotcSdk.GamerAccountMethods.Convert(System.String,System.String,System.String,CotcSdk.Bundle)">
            <summary>
            Converts the account to sign in through another network.
            For instance, you might have created an anonymous account, that you later want to convert to an account
            logged on through a facebook account. Or, should you later want to convert this account to simply use an
            e-mail address, this is the method that you will want to call.
            In order to convert the account successfully, the provided network credentials need to be acceptable,
            just as when calling #CotcSdk.Cloud.Login.
            </summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="network">The target network to connect with later on.</param>
            <param name="networkId">The ID on the network. For example, with the facebook network, this would be the User ID.
                On e-mail accounts e-mail then, this would be the e-mail address.</param>
            <param name="networkSecret">The secret for the network. For e-mail accounts, this would be the passord. For
                facebook or other SNS accounts, this would be the user token.</param>
            <param name="options">An optional JSON to customize the convert process.</param>
        </member>
        <member name="M:CotcSdk.GamerAccountMethods.Link(System.String,System.String,System.String,CotcSdk.Bundle)">
            <summary>
            Links the account with another social network. Note that unlike Convert, this doesn't change the way the
            user would then sign in (the credentials remain the same).
            For instance, one may want to link their facebook account while keeping e-mail credentials in order to
            be able to share and play against gamers from their facebook social circle.
            In order to link the account successfully, the provided network credentials need to be acceptable,
            just as when calling #CotcSdk.Cloud.Login.
            </summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="network">The target network to link the account with.</param>
            <param name="networkId">The ID on the network. For example, with the facebook network, this would be the User ID.
                On e-mail accounts e-mail then, this would be the e-mail address.</param>
            <param name="networkSecret">The secret for the network. For e-mail accounts, this would be the passord. For
                facebook or other SNS accounts, this would be the user token.</param>
            <param name="options">An optional JSON to customize the convert process.</param>
        </member>
        <member name="M:CotcSdk.GamerAccountMethods.Unlink(System.String)">
            <summary>
            Unlinks the account with a social network.
            </summary>
            <returns>Promise resolved when the operation has completed.</returns>
            <param name="network">The target network to unlink the account from.</param>
        </member>
        <member name="M:CotcSdk.GamerAccountMethods.RegisterDevice(System.String,System.String)">
            <summary>Meant to be called for push notifications.</summary>
            <param name="os">Operating system (should be determined by the native implementation: "ios", "android", "macos", ).</param>
            <param name="token">Push notification token (device specific).</param>
        </member>
        <member name="M:CotcSdk.GamerAccountMethods.UnregisterDevice(System.String,System.String)">
            <summary>Unregisters a previously registered device (see #RegisterDevice).</summary>
            <param name="os">Operating system (should be determined by the native implementation: "ios", "android", "macos", ).</param>
            <param name="token">Push notification token (device specific).</param>
        </member>
        <member name="T:Ionic.Crc.CRC32">
            <summary>
              Computes a CRC-32. The CRC-32 algorithm is parameterized - you
              can set the polynomial and enable or disable bit
              reversal. This can be used for GZIP, BZip2, or ZIP.
            </summary>
            <remarks>
              This type is used internally by DotNetZip; it is generally not used
              directly by applications wishing to create, read, or manipulate zip
              archive files.
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CRC32.TotalBytesRead">
            <summary>
              Indicates the total number of bytes applied to the CRC.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CRC32.Crc32Result">
            <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CRC32.GetCrc32(System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream, and writes the input into the
            output stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <param name="output">The stream into which to deflate the input</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.ComputeCrc32(System.Int32,System.Byte)">
            <summary>
              Get the CRC32 for the given (word,byte) combo.  This is a
              computation defined by PKzip for PKZIP 2.0 (weak) encryption.
            </summary>
            <param name="W">The word to start with.</param>
            <param name="B">The byte to combine it with.</param>
            <returns>The CRC-ized result.</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.SlurpBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the value for the running CRC32 using the given block of bytes.
            This is useful when using the CRC32() class in a Stream.
            </summary>
            <param name="block">block of bytes to slurp</param>
            <param name="offset">starting point in the block</param>
            <param name="count">how many bytes within the block to slurp</param>
        </member>
        <member name="M:Ionic.Crc.CRC32.UpdateCRC(System.Byte)">
            <summary>
              Process one byte in the CRC.
            </summary>
            <param name = "b">the byte to include into the CRC .  </param>
        </member>
        <member name="M:Ionic.Crc.CRC32.UpdateCRC(System.Byte,System.Int32)">
            <summary>
              Process a run of N identical bytes into the CRC.
            </summary>
            <remarks>
              <para>
                This method serves as an optimization for updating the CRC when a
                run of identical bytes is found. Rather than passing in a buffer of
                length n, containing all identical bytes b, this method accepts the
                byte value and the length of the (virtual) buffer - the length of
                the run.
              </para>
            </remarks>
            <param name = "b">the byte to include into the CRC.  </param>
            <param name = "n">the number of times that byte should be repeated. </param>
        </member>
        <member name="M:Ionic.Crc.CRC32.Combine(System.Int32,System.Int32)">
            <summary>
              Combines the given CRC32 value with the current running total.
            </summary>
            <remarks>
              This is useful when using a divide-and-conquer approach to
              calculating a CRC.  Multiple threads can each calculate a
              CRC32 on a segment of the data, and then combine the
              individual CRC32 values at the end.
            </remarks>
            <param name="crc">the crc value to be combined with this one</param>
            <param name="length">the length of data the CRC value was calculated on</param>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor">
            <summary>
              Create an instance of the CRC32 class using the default settings: no
              bit reversal, and a polynomial of 0xEDB88320.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor(System.Boolean)">
            <summary>
              Create an instance of the CRC32 class, specifying whether to reverse
              data bits or not.
            </summary>
            <param name='reverseBits'>
              specify true if the instance should reverse data bits.
            </param>
            <remarks>
              <para>
                In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                want a CRC32 with compatibility with BZip2, you should pass true
                here. In the CRC-32 used by GZIP and PKZIP, the bits are not
                reversed; Therefore if you want a CRC32 with compatibility with
                those, you should pass false.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor(System.Int32,System.Boolean)">
             <summary>
               Create an instance of the CRC32 class, specifying the polynomial and
               whether to reverse data bits or not.
             </summary>
             <param name='polynomial'>
               The polynomial to use for the CRC, expressed in the reversed (LSB)
               format: the highest ordered bit in the polynomial value is the
               coefficient of the 0th power; the second-highest order bit is the
               coefficient of the 1 power, and so on. Expressed this way, the
               polynomial for the CRC-32C used in IEEE 802.3, is 0xEDB88320.
             </param>
             <param name='reverseBits'>
               specify true if the instance should reverse data bits.
             </param>
            
             <remarks>
               <para>
                 In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                 want a CRC32 with compatibility with BZip2, you should pass true
                 here for the <c>reverseBits</c> parameter. In the CRC-32 used by
                 GZIP and PKZIP, the bits are not reversed; Therefore if you want a
                 CRC32 with compatibility with those, you should pass false for the
                 <c>reverseBits</c> parameter.
               </para>
             </remarks>
        </member>
        <member name="M:Ionic.Crc.CRC32.Reset">
            <summary>
              Reset the CRC-32 class - clear the CRC "remainder register."
            </summary>
            <remarks>
              <para>
                Use this when employing a single instance of this class to compute
                multiple, distinct CRCs on multiple, distinct data blocks.
              </para>
            </remarks>
        </member>
        <member name="T:Ionic.Crc.CrcCalculatorStream">
             <summary>
             A Stream that calculates a CRC32 (a checksum) on all bytes read,
             or on all bytes written.
             </summary>
            
             <remarks>
             <para>
             This class can be used to verify the CRC of a ZipEntry when
             reading from a stream, or to calculate a CRC when writing to a
             stream.  The stream should be used to either read, or write, but
             not both.  If you intermix reads and writes, the results are not
             defined.
             </para>
            
             <para>
             This class is intended primarily for use internally by the
             DotNetZip library.
             </para>
             </remarks>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream)">
            <summary>
            The default constructor.
            </summary>
            <remarks>
              <para>
                Instances returned from this constructor will leave the underlying
                stream open upon Close().  The stream uses the default CRC32
                algorithm, which implies a polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
              The constructor allows the caller to specify how to handle the
              underlying stream at close.
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read.
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
              <para>
                Instances returned from this constructor will leave the underlying
                stream open upon Close().
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read, as well as whether to keep the underlying stream open upon
              Close().
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean,Ionic.Crc.CRC32)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read, as well as whether to keep the underlying stream open upon
              Close(), and the CRC32 instance to use.
            </summary>
            <remarks>
              <para>
                The stream uses the specified CRC32 instance, which allows the
                application to specify how the CRC gets calculated.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
            <param name="crc32">the CRC32 instance to use to calculate the CRC32</param>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.TotalBytesSlurped">
             <summary>
               Gets the total number of bytes run through the CRC32 calculator.
             </summary>
            
             <remarks>
               This is either the total number of bytes read, or the total number of
               bytes written, depending on the direction of this stream.
             </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Crc">
            <summary>
              Provides the current CRC for all blocks slurped in.
            </summary>
            <remarks>
              <para>
                The running total of the CRC is kept as data is written or read
                through the stream.  read this property after all reads or writes to
                get an accurate CRC for the entire stream.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.LeaveOpen">
            <summary>
              Indicates whether the underlying stream will be left open when the
              <c>CrcCalculatorStream</c> is Closed.
            </summary>
            <remarks>
              <para>
                Set this at any point before calling <see cref="M:Ionic.Crc.CrcCalculatorStream.Close"/>.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from the stream
            </summary>
            <param name="buffer">the buffer to read</param>
            <param name="offset">the offset at which to start</param>
            <param name="count">the number of bytes to read</param>
            <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write to the stream.
            </summary>
            <param name="buffer">the buffer from which to write</param>
            <param name="offset">the offset at which to start writing</param>
            <param name="count">the number of bytes to write</param>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanRead">
            <summary>
            Indicates whether the stream supports reading.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanSeek">
            <summary>
              Indicates whether the stream supports seeking.
            </summary>
            <remarks>
              <para>
                Always returns false.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanWrite">
            <summary>
            Indicates whether the stream supports writing.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Length">
            <summary>
              Returns the length of the underlying stream.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Position">
            <summary>
              The getter for this property returns the total bytes read.
              If you use the setter, it will throw
            <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seeking is not supported on this stream. This method always throws
            <see cref="T:System.NotSupportedException"/>
            </summary>
            <param name="offset">N/A</param>
            <param name="origin">N/A</param>
            <returns>N/A</returns>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.SetLength(System.Int64)">
            <summary>
            This method always throws
            <see cref="T:System.NotSupportedException"/>
            </summary>
            <param name="value">N/A</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Close">
            <summary>
            Closes the stream.
            </summary>
        </member>
        <member name="T:Ionic.Encoding.Iso8859Dash1Encoding">
            <summary>
            Provides a text encoder for the iso-8859-1 encoding, aka Latin1 encoding,
            for platforms that do not support it, for example on Silverlight or some
            Compact Framework platforms.
            </summary>
        </member>
        <member name="P:Ionic.Encoding.Iso8859Dash1Encoding.WebName">
            <summary>
            Gets the name registered with the
            Internet Assigned Numbers Authority (IANA) for the current encoding.
            </summary>
            <returns>
            Always returns "iso-8859-1".
            </returns>
        </member>
        <member name="M:Ionic.Encoding.Iso8859Dash1Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encodes a set of characters from a character array into
            a byte array.
            </summary>
            <returns>
            The actual number of bytes written into <paramref name="bytes"/>.
            </returns>
            <param name="chars">The character array containing the set of characters to encode.
            </param><param name="start">The index of the first character to encode.
            </param><param name="count">The number of characters to encode.
            </param><param name="bytes">The byte array to contain the resulting sequence of bytes.
            </param><param name="byteIndex">The index at which to start writing the resulting sequence of bytes.
            </param>
        </member>
        <member name="M:Ionic.Encoding.Iso8859Dash1Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
            <summary>
            Decodes a sequence of bytes from the specified byte array into the specified character array.
            </summary>
            <returns>
            The actual number of characters written into <paramref name="chars"/>.
            </returns>
            <param name="bytes">The byte array containing the sequence of bytes to decode.
            </param><param name="start">The index of the first byte to decode.
            </param><param name="count">The number of bytes to decode.
            </param><param name="chars">The character array to contain the resulting set of characters.
            </param><param name="charIndex">The index at which to start writing the resulting set of characters.
            </param>
        </member>
        <member name="M:Ionic.Encoding.Iso8859Dash1Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
            <summary>
            Calculates the number of bytes produced by encoding a set of characters
            from the specified character array.
            </summary>
            <returns>
            The number of bytes produced by encoding the specified characters. This class
            alwas returns the value of <paramref name="count"/>.
            </returns>
        </member>
        <member name="M:Ionic.Encoding.Iso8859Dash1Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Calculates the number of characters produced by decoding a sequence
            of bytes from the specified byte array.
            </summary>
            <returns>
            The number of characters produced by decoding the specified sequence of bytes. This class
            alwas returns the value of <paramref name="count"/>.
            </returns>
        </member>
        <member name="M:Ionic.Encoding.Iso8859Dash1Encoding.GetMaxByteCount(System.Int32)">
            <summary>
            Calculates the maximum number of bytes produced by encoding the specified number of characters.
            </summary>
            <returns>
            The maximum number of bytes produced by encoding the specified number of characters. This
            class alwas returns the value of <paramref name="charCount"/>.
            </returns>
            <param name="charCount">The number of characters to encode.
            </param>
        </member>
        <member name="M:Ionic.Encoding.Iso8859Dash1Encoding.GetMaxCharCount(System.Int32)">
            <summary>
            Calculates the maximum number of characters produced by decoding the specified number of bytes.
            </summary>
            <returns>
            The maximum number of characters produced by decoding the specified number of bytes. This class
            alwas returns the value of <paramref name="byteCount"/>.
            </returns>
            <param name="byteCount">The number of bytes to decode.</param>
        </member>
        <member name="P:Ionic.Encoding.Iso8859Dash1Encoding.CharacterCount">
            <summary>
            Gets the number of characters that are supported by this encoding.
            This property returns a maximum value of 256, as the encoding class
            only supports single byte encodings (1 byte == 256 possible values).
            </summary>
        </member>
        <member name="T:Ionic.Zlib.DeflateStream">
             <summary>
             A class for compressing and decompressing streams using the Deflate algorithm.
             </summary>
            
             <remarks>
            
             <para>
               The DeflateStream is a <see
               href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see
               cref="T:System.IO.Stream"/>.  It adds DEFLATE compression or decompression to any
               stream.
             </para>
            
             <para>
               Using this stream, applications can compress or decompress data via stream
               <c>Read</c> and <c>Write</c> operations.  Either compresssion or decompression
               can occur through either reading or writing. The compression format used is
               DEFLATE, which is documented in <see
               href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
               Compressed Data Format Specification version 1.3.".
             </para>
            
             <para>
               This class is similar to <see cref="T:Ionic.Zlib.ZlibStream"/>, except that
               <c>ZlibStream</c> adds the <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
               1950 - ZLIB</see> framing bytes to a compressed stream when compressing, or
               expects the RFC1950 framing bytes when decompressing. The <c>DeflateStream</c>
               does not.
             </para>
            
             </remarks>
            
             <seealso cref="T:Ionic.Zlib.ZlibStream" />
             <seealso cref="T:Ionic.Zlib.GZipStream" />
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
             <summary>
               Create a DeflateStream using the specified CompressionMode.
             </summary>
            
             <remarks>
               When mode is <c>CompressionMode.Compress</c>, the DeflateStream will use
               the default compression level. The "captive" stream will be closed when
               the DeflateStream is closed.
             </remarks>
            
             <example>
             This example uses a DeflateStream to compress data from a file, and writes
             the compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
             <summary>
             Create a DeflateStream using the specified CompressionMode and the specified CompressionLevel.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is
               ignored.  The "captive" stream will be closed when the DeflateStream is
               closed.
             </para>
            
             </remarks>
            
             <example>
            
               This example uses a DeflateStream to compress data from a file, and writes
               the compressed data to another file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw,
                                                                  CompressionMode.Compress,
                                                                  CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>DeflateStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>DeflateStream</c> using the specified
               <c>CompressionMode</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compression.  Specify true for
               the <paramref name="leaveOpen"/> parameter to leave the stream open.
             </para>
            
             <para>
               The <c>DeflateStream</c> will use the default compression level.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the
               "captive" stream in other places in this documentation.
             </param>
            
             <param name="mode">
               Indicates whether the <c>DeflateStream</c> will compress or decompress.
             </param>
            
             <param name="leaveOpen">true if the application would like the stream to
             remain open after inflation/deflation.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>DeflateStream</c> using the specified <c>CompressionMode</c>
               and the specified <c>CompressionLevel</c>, and explicitly specify whether
               the stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
             </para>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               <see cref="T:System.IO.MemoryStream"/> that will be re-read after
               compression.  Specify true for the <paramref name="leaveOpen"/> parameter
               to leave the stream open.
             </para>
            
             </remarks>
            
             <example>
            
               This example shows how to use a <c>DeflateStream</c> to compress data from
               a file, and store the compressed data into another file.
            
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".deflated"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code>
            
             <code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".deflated")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
            <remarks> See the ZLIB documentation for the meaning of the flush behavior.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.Strategy">
             <summary>
               The ZLIB strategy to be used during compression.
             </summary>
            
             <remarks>
               By tweaking this parameter, you may be able to optimize the compression for
               data with particular characteristics.
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                Application code won't call this code directly.  This method may be
                invoked in two distinct scenarios.  If disposing == true, the method
                has been called directly or indirectly by a user's code, for example
                via the public Dispose() method. In this case, both managed and
                unmanaged resources can be referenced and disposed.  If disposing ==
                false, the method has been called by the runtime from inside the
                object finalizer and this method should not reference other objects;
                in that case only unmanaged resources must be referenced or
                disposed.
              </para>
            </remarks>
            <param name="disposing">
              true if the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.Position">
             <summary>
             The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Read data from the stream.
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, providing an uncompressed data stream.
               Then call Read() on that <c>DeflateStream</c>, and the data read will be
               compressed as you read.  If you wish to use the <c>DeflateStream</c> to
               decompress data while reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, providing a readable compressed data
               stream.  Then call Read() on that <c>DeflateStream</c>, and the data read
               will be decompressed as you read.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
             </para>
            
             </remarks>
             <param name="buffer">The buffer into which the read data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, and a writable output stream.  Then call
               <c>Write()</c> on that <c>DeflateStream</c>, providing uncompressed data
               as input.  The data sent to the output stream will be the compressed form
               of the data written.  If you wish to use the <c>DeflateStream</c> to
               decompress data while writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, and a writable output stream.  Then
               call <c>Write()</c> on that stream, providing previously compressed
               data. The data sent to the output stream will be the decompressed form of
               the data written.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>,
               but not both.
             </para>
            
             </remarks>
            
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using DEFLATE (RFC 1951).
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])">DeflateStream.UncompressString(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])">DeflateStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)">GZipStream.CompressString(string)</seealso>
             <seealso cref="M:Ionic.Zlib.ZlibStream.CompressString(System.String)">ZlibStream.CompressString(string)</seealso>
            
             <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using DEFLATE.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.DeflateStream.CompressString(System.String)">DeflateStream.CompressString(string)</seealso>
             <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">DeflateStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])">GZipStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])">ZlibStream.CompressBuffer(byte[])</seealso>
            
             <param name="b">
               A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a DEFLATE'd byte array into a single string.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.DeflateStream.CompressString(System.String)">DeflateStream.CompressString(String)</seealso>
             <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">DeflateStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])">GZipStream.UncompressString(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])">ZlibStream.UncompressString(byte[])</seealso>
            
             <param name="compressed">
               A buffer containing DEFLATE-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a DEFLATE'd byte array into a byte array.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])">DeflateStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])">DeflateStream.UncompressString(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])">GZipStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])">ZlibStream.UncompressBuffer(byte[])</seealso>
            
             <param name="compressed">
               A buffer containing data that has been compressed with DEFLATE.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="T:Ionic.Zlib.GZipStream">
             <summary>
               A class for compressing and decompressing GZIP streams.
             </summary>
             <remarks>
            
             <para>
               The <c>GZipStream</c> is a <see
               href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a
               <see cref="T:System.IO.Stream"/>. It adds GZIP compression or decompression to any
               stream.
             </para>
            
             <para>
               Like the <c>System.IO.Compression.GZipStream</c> in the .NET Base Class Library, the
               <c>Ionic.Zlib.GZipStream</c> can compress while writing, or decompress while
               reading, but not vice versa.  The compression method used is GZIP, which is
               documented in <see href="http://www.ietf.org/rfc/rfc1952.txt">IETF RFC
               1952</see>, "GZIP file format specification version 4.3".</para>
            
             <para>
               A <c>GZipStream</c> can be used to decompress data (through <c>Read()</c>) or
               to compress data (through <c>Write()</c>), but not both.
             </para>
            
             <para>
               If you wish to use the <c>GZipStream</c> to compress data, you must wrap it
               around a write-able stream. As you call <c>Write()</c> on the <c>GZipStream</c>, the
               data will be compressed into the GZIP format.  If you want to decompress data,
               you must wrap the <c>GZipStream</c> around a readable stream that contains an
               IETF RFC 1952-compliant stream.  The data will be decompressed as you call
               <c>Read()</c> on the <c>GZipStream</c>.
             </para>
            
             <para>
               Though the GZIP format allows data from multiple files to be concatenated
               together, this stream handles only a single segment of GZIP format, typically
               representing a single file.
             </para>
            
             <para>
               This class is similar to <see cref="T:Ionic.Zlib.ZlibStream"/> and <see cref="T:Ionic.Zlib.DeflateStream"/>.
               <c>ZlibStream</c> handles RFC1950-compliant streams.  <see cref="T:Ionic.Zlib.DeflateStream"/>
               handles RFC1951-compliant streams. This class handles RFC1952-compliant streams.
             </para>
            
             </remarks>
            
             <seealso cref="T:Ionic.Zlib.DeflateStream" />
             <seealso cref="T:Ionic.Zlib.ZlibStream" />
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Comment">
             <summary>
               The comment on the GZIP stream.
             </summary>
            
             <remarks>
             <para>
               The GZIP format allows for each file to optionally have an associated
               comment stored with the file.  The comment is encoded with the ISO-8859-1
               code page.  To include a comment in a GZIP stream you create, set this
               property before calling <c>Write()</c> for the first time on the
               <c>GZipStream</c>.
             </para>
            
             <para>
               When using <c>GZipStream</c> to decompress, you can retrieve this property
               after the first call to <c>Read()</c>.  If no comment has been set in the
               GZIP bytestream, the Comment property will return <c>null</c>
               (<c>Nothing</c> in VB).
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.FileName">
             <summary>
               The FileName for the GZIP stream.
             </summary>
            
             <remarks>
            
             <para>
               The GZIP format optionally allows each file to have an associated
               filename.  When compressing data (through <c>Write()</c>), set this
               FileName before calling <c>Write()</c> the first time on the <c>GZipStream</c>.
               The actual filename is encoded into the GZIP bytestream with the
               ISO-8859-1 code page, according to RFC 1952. It is the application's
               responsibility to insure that the FileName can be encoded and decoded
               correctly with this code page.
             </para>
            
             <para>
               When decompressing (through <c>Read()</c>), you can retrieve this value
               any time after the first <c>Read()</c>.  In the case where there was no filename
               encoded into the GZIP bytestream, the property will return <c>null</c> (<c>Nothing</c>
               in VB).
             </para>
             </remarks>
        </member>
        <member name="F:Ionic.Zlib.GZipStream.LastModified">
             <summary>
               The last modified time for the GZIP stream.
             </summary>
            
             <remarks>
               GZIP allows the storage of a last modified time with each GZIP entry.
               When compressing data, you can set this before the first call to
               <c>Write()</c>.  When decompressing, you can retrieve this value any time
               after the first call to <c>Read()</c>.
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Crc32">
            <summary>
            The CRC on the GZIP stream.
            </summary>
            <remarks>
            This is used for internal error checking. You probably don't need to look at this property.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>.
             </summary>
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>GZipStream</c> will use the
               default compression level.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with
               <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a GZipStream to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
            
             <example>
             This example shows how to use a GZipStream to uncompress a file.
             <code>
             private void GunZipFile(string filename)
             {
                 if (!filename.EndsWith(".gz))
                     throw new ArgumentException("filename");
                 var DecompressedFile = filename.Substring(0,filename.Length-3);
                 byte[] working = new byte[WORKING_BUFFER_SIZE];
                 int n= 1;
                 using (System.IO.Stream input = System.IO.File.OpenRead(filename))
                 {
                     using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                     {
                         using (var output = System.IO.File.Create(DecompressedFile))
                         {
                             while (n !=0)
                             {
                                 n= decompressor.Read(working, 0, working.Length);
                                 if (n > 0)
                                 {
                                     output.Write(working, 0, n);
                                 }
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub GunZipFile(ByVal filename as String)
                 If Not (filename.EndsWith(".gz)) Then
                     Throw New ArgumentException("filename")
                 End If
                 Dim DecompressedFile as String = filename.Substring(0,filename.Length-3)
                 Dim working(WORKING_BUFFER_SIZE) as Byte
                 Dim n As Integer = 1
                 Using input As Stream = File.OpenRead(filename)
                     Using decompressor As Stream = new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, True)
                         Using output As Stream = File.Create(UncompressedFile)
                             Do
                                 n= decompressor.Read(working, 0, working.Length)
                                 If n > 0 Then
                                     output.Write(working, 0, n)
                                 End IF
                             Loop While (n  > 0)
                         End Using
                     End Using
                 End Using
             End Sub
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and
               the specified <c>CompressionLevel</c>.
             </summary>
             <remarks>
            
             <para>
               The <c>CompressionMode</c> (Compress or Decompress) also establishes the
               "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A
               <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a <c>GZipStream</c> to compress a file into a .gz file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".gz"))
                 {
                     using (Stream compressor = new GZipStream(raw,
                                                               CompressionMode.Compress,
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".gz")
                     Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>GZipStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>, and
               explicitly specify whether the stream should be left open after Deflation
               or Inflation.
             </summary>
            
             <remarks>
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to leave
               the stream open.
             </para>
            
             <para>
               The <see cref="T:Ionic.Zlib.CompressionMode"/> (Compress or Decompress) also
               establishes the "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A <c>GZipStream</c>
               with <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             <para>
               The <c>GZipStream</c> will use the default compression level. If you want
               to specify the compression level, see <see cref="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)"/>.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
            
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the "captive"
               stream in other places in this documentation.
             </param>
            
             <param name="mode">Indicates whether the GZipStream will compress or decompress.
             </param>
            
             <param name="leaveOpen">
               true if the application would like the base stream to remain open after
               inflation/deflation.
             </param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and the
               specified <c>CompressionLevel</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to
               leave the stream open.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a <c>GZipStream</c> to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                This method may be invoked in two distinct scenarios.  If disposing
                == true, the method has been called directly or indirectly by a
                user's code, for example via the public Dispose() method. In this
                case, both managed and unmanaged resources can be referenced and
                disposed.  If disposing == false, the method has been called by the
                runtime from inside the object finalizer and this method should not
                reference other objects; in that case only unmanaged resources must
                be referenced or disposed.
              </para>
            </remarks>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Position">
             <summary>
               The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Read and decompress data from the source stream.
             </summary>
            
             <remarks>
               With a <c>GZipStream</c>, decompression is done through reading.
             </remarks>
            
             <example>
             <code>
             byte[] working = new byte[WORKING_BUFFER_SIZE];
             using (System.IO.Stream input = System.IO.File.OpenRead(_CompressedFile))
             {
                 using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                 {
                     using (var output = System.IO.File.Create(_DecompressedFile))
                     {
                         int n;
                         while ((n= decompressor.Read(working, 0, working.Length)) !=0)
                         {
                             output.Write(working, 0, n);
                         }
                     }
                 }
             }
             </code>
             </example>
             <param name="buffer">The buffer into which the decompressed data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">irrelevant; it will always throw!</param>
            <param name="origin">irrelevant; it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.SetLength(System.Int64)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">irrelevant; this method will always throw!</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
            
             <remarks>
             <para>
               If you wish to use the <c>GZipStream</c> to compress data while writing,
               you can create a <c>GZipStream</c> with <c>CompressionMode.Compress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that <c>GZipStream</c>,
               providing uncompressed data as input.  The data sent to the output stream
               will be the compressed form of the data written.
             </para>
            
             <para>
               A <c>GZipStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not
               both. Writing implies compression.  Reading implies decompression.
             </para>
            
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using GZip.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])"/>
            
             <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using GZip.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="b">
               A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a GZip'ed byte array into a single string.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing GZIP-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a GZip'ed byte array into a byte array.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing data that has been compressed with GZip.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="T:Ionic.Zlib.ParallelDeflateOutputStream">
             <summary>
               A class for compressing streams using the
               Deflate algorithm with multiple threads.
             </summary>
            
             <remarks>
             <para>
               This class performs DEFLATE compression through writing.  For
               more information on the Deflate algorithm, see IETF RFC 1951,
               "DEFLATE Compressed Data Format Specification version 1.3."
             </para>
            
             <para>
               This class is similar to <see cref="T:Ionic.Zlib.DeflateStream"/>, except
               that this class is for compression only, and this implementation uses an
               approach that employs multiple worker threads to perform the DEFLATE.  On
               a multi-cpu or multi-core computer, the performance of this class can be
               significantly higher than the single-threaded DeflateStream, particularly
               for larger streams.  How large?  Anything over 10mb is a good candidate
               for parallel compression.
             </para>
            
             <para>
               The tradeoff is that this class uses more memory and more CPU than the
               vanilla DeflateStream, and also is less efficient as a compressor. For
               large files the size of the compressed data stream can be less than 1%
               larger than the size of a compressed data stream from the vanialla
               DeflateStream.  For smaller files the difference can be larger.  The
               difference will also be larger if you set the BufferSize to be lower than
               the default value.  Your mileage may vary. Finally, for small files, the
               ParallelDeflateOutputStream can be much slower than the vanilla
               DeflateStream, because of the overhead associated to using the thread
               pool.
             </para>
            
             </remarks>
             <seealso cref="T:Ionic.Zlib.DeflateStream" />
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)">
             <summary>
             Create a ParallelDeflateOutputStream.
             </summary>
             <remarks>
            
             <para>
               This stream compresses data written into it via the DEFLATE
               algorithm (see RFC 1951), and writes out the compressed byte stream.
             </para>
            
             <para>
               The instance will use the default compression level, the default
               buffer sizes and the default number of threads and buffers per
               thread.
             </para>
            
             <para>
               This class is similar to <see cref="T:Ionic.Zlib.DeflateStream"/>,
               except that this implementation uses an approach that employs
               multiple worker threads to perform the DEFLATE.  On a multi-cpu or
               multi-core computer, the performance of this class can be
               significantly higher than the single-threaded DeflateStream,
               particularly for larger streams.  How large?  Anything over 10mb is
               a good candidate for parallel compression.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a ParallelDeflateOutputStream to compress
             data.  It reads a file, compresses it, and writes the compressed data to
             a second, output file.
            
             <code>
             byte[] buffer = new byte[WORKING_BUFFER_SIZE];
             int n= -1;
             String outputFile = fileToCompress + ".compressed";
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new ParallelDeflateOutputStream(raw))
                     {
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim buffer As Byte() = New Byte(4096) {}
             Dim n As Integer = -1
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                     Using compressor As Stream = New ParallelDeflateOutputStream(raw)
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to which compressed data will be written.</param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionLevel)">
            <summary>
              Create a ParallelDeflateOutputStream using the specified CompressionLevel.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream and specify whether to leave the captive stream open
            when the ParallelDeflateOutputStream is closed.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionLevel,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream and specify whether to leave the captive stream open
            when the ParallelDeflateOutputStream is closed.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionLevel,Ionic.Zlib.CompressionStrategy,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream using the specified
            CompressionLevel and CompressionStrategy, and specifying whether to
            leave the captive stream open when the ParallelDeflateOutputStream is
            closed.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
            <param name="strategy">
              By tweaking this parameter, you may be able to optimize the compression for
              data with particular characteristics.
            </param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Strategy">
             <summary>
               The ZLIB strategy to be used during compression.
             </summary>
            
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.MaxBufferPairs">
             <summary>
               The maximum number of buffer pairs to use.
             </summary>
            
             <remarks>
             <para>
               This property sets an upper limit on the number of memory buffer
               pairs to create.  The implementation of this stream allocates
               multiple buffers to facilitate parallel compression.  As each buffer
               fills up, this stream uses <see
               cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
               ThreadPool.QueueUserWorkItem()</see>
               to compress those buffers in a background threadpool thread. After a
               buffer is compressed, it is re-ordered and written to the output
               stream.
             </para>
            
             <para>
               A higher number of buffer pairs enables a higher degree of
               parallelism, which tends to increase the speed of compression on
               multi-cpu computers.  On the other hand, a higher number of buffer
               pairs also implies a larger memory consumption, more active worker
               threads, and a higher cpu utilization for any compression. This
               property enables the application to limit its memory consumption and
               CPU utilization behavior depending on requirements.
             </para>
            
             <para>
               For each compression "task" that occurs in parallel, there are 2
               buffers allocated: one for input and one for output.  This property
               sets a limit for the number of pairs.  The total amount of storage
               space allocated for buffering will then be (N*S*2), where N is the
               number of buffer pairs, S is the size of each buffer (<see
               cref="P:Ionic.Zlib.ParallelDeflateOutputStream.BufferSize"/>).  By default, DotNetZip allocates 4 buffer
               pairs per CPU core, so if your machine has 4 cores, and you retain
               the default buffer size of 128k, then the
               ParallelDeflateOutputStream will use 4 * 4 * 2 * 128kb of buffer
               memory in total, or 4mb, in blocks of 128kb.  If you then set this
               property to 8, then the number will be 8 * 2 * 128kb of buffer
               memory, or 2mb.
             </para>
            
             <para>
               CPU utilization will also go up with additional buffers, because a
               larger number of buffer pairs allows a larger number of background
               threads to compress in parallel. If you find that parallel
               compression is consuming too much memory or CPU, you can adjust this
               value downward.
             </para>
            
             <para>
               The default value is 16. Different values may deliver better or
               worse results, depending on your priorities and the dynamic
               performance characteristics of your storage and compute resources.
             </para>
            
             <para>
               This property is not the number of buffer pairs to use; it is an
               upper limit. An illustration: Suppose you have an application that
               uses the default value of this property (which is 16), and it runs
               on a machine with 2 CPU cores. In that case, DotNetZip will allocate
               4 buffer pairs per CPU core, for a total of 8 pairs.  The upper
               limit specified by this property has no effect.
             </para>
            
             <para>
               The application can set this value at any time, but it is effective
               only before the first call to Write(), which is when the buffers are
               allocated.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.BufferSize">
             <summary>
               The size of the buffers used by the compressor threads.
             </summary>
             <remarks>
            
             <para>
               The default buffer size is 128k. The application can set this value
               at any time, but it is effective only before the first Write().
             </para>
            
             <para>
               Larger buffer sizes implies larger memory consumption but allows
               more efficient compression. Using smaller buffer sizes consumes less
               memory but may result in less effective compression.  For example,
               using the default buffer size of 128k, the compression delivered is
               within 1% of the compression delivered by the single-threaded <see
               cref="T:Ionic.Zlib.DeflateStream"/>.  On the other hand, using a
               BufferSize of 8k can result in a compressed data stream that is 5%
               larger than that delivered by the single-threaded
               <c>DeflateStream</c>.  Excessively small buffer sizes can also cause
               the speed of the ParallelDeflateOutputStream to drop, because of
               larger thread scheduling overhead dealing with many many small
               buffers.
             </para>
            
             <para>
               The total amount of storage space allocated for buffering will be
               (N*S*2), where N is the number of buffer pairs, and S is the size of
               each buffer (this property). There are 2 buffers used by the
               compressor, one for input and one for output.  By default, DotNetZip
               allocates 4 buffer pairs per CPU core, so if your machine has 4
               cores, then the number of buffer pairs used will be 16. If you
               accept the default value of this property, 128k, then the
               ParallelDeflateOutputStream will use 16 * 2 * 128kb of buffer memory
               in total, or 4mb, in blocks of 128kb.  If you set this property to
               64kb, then the number will be 16 * 2 * 64kb of buffer memory, or
               2mb.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Crc32">
            <summary>
            The CRC32 for the data that was written out, prior to compression.
            </summary>
            <remarks>
            This value is meaningful only after a call to Close().
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.BytesProcessed">
            <summary>
            The total number of uncompressed bytes processed by the ParallelDeflateOutputStream.
            </summary>
            <remarks>
            This value is meaningful only after a call to Close().
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
            
             <remarks>
            
             <para>
               To use the ParallelDeflateOutputStream to compress data, create a
               ParallelDeflateOutputStream with CompressionMode.Compress, passing a
               writable output stream.  Then call Write() on that
               ParallelDeflateOutputStream, providing uncompressed data as input.  The
               data sent to the output stream will be the compressed form of the data
               written.
             </para>
            
             <para>
               To decompress data, use the <see cref="T:Ionic.Zlib.DeflateStream"/> class.
             </para>
            
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Close">
            <summary>
            Close the stream.
            </summary>
            <remarks>
            You must call Close on the stream to guarantee that all of the data written in has
            been compressed, and the compressed data has been written out.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Dispose">
            <summary>Dispose the object</summary>
            <remarks>
              <para>
                Because ParallelDeflateOutputStream is IDisposable, the
                application must call this method when finished using the instance.
              </para>
              <para>
                This method is generally called implicitly upon exit from
                a <c>using</c> scope in C# (<c>Using</c> in VB).
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Dispose(System.Boolean)">
            <summary>The Dispose method</summary>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Reset(System.IO.Stream)">
             <summary>
               Resets the stream for use with another stream.
             </summary>
             <remarks>
               Because the ParallelDeflateOutputStream is expensive to create, it
               has been designed so that it can be recycled and re-used.  You have
               to call Close() on the stream first, then you can call Reset() on
               it, to use it again on another stream.
             </remarks>
            
             <param name="stream">
               The new output stream for this era.
             </param>
            
             <example>
             <code>
             ParallelDeflateOutputStream deflater = null;
             foreach (var inputFile in listOfFiles)
             {
                 string outputFile = inputFile + ".compressed";
                 using (System.IO.Stream input = System.IO.File.OpenRead(inputFile))
                 {
                     using (var outStream = System.IO.File.Create(outputFile))
                     {
                         if (deflater == null)
                             deflater = new ParallelDeflateOutputStream(outStream,
                                                                        CompressionLevel.Best,
                                                                        CompressionStrategy.Default,
                                                                        true);
                         deflater.Reset(outStream);
            
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             deflater.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.CanRead">
            <summary>
            Indicates whether the stream supports Read operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.CanWrite">
            <summary>
            Indicates whether the stream supports Write operations.
            </summary>
            <remarks>
            Returns true if the provided stream is writable.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Length">
            <summary>
            Reading this property always throws a NotSupportedException.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Position">
            <summary>
            Returns the current position of the output stream.
            </summary>
            <remarks>
              <para>
                Because the output gets written by a background thread,
                the value may change asynchronously.  Setting this
                property always throws a NotSupportedException.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="buffer">
              The buffer into which data would be read, IF THIS METHOD
              ACTUALLY DID ANYTHING.
            </param>
            <param name="offset">
              The offset within that data array at which to insert the
              data that is read, IF THIS METHOD ACTUALLY DID
              ANYTHING.
            </param>
            <param name="count">
              The number of bytes to write, IF THIS METHOD ACTUALLY DID
              ANYTHING.
            </param>
            <returns>nothing.</returns>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="offset">
              The offset to seek to....
              IF THIS METHOD ACTUALLY DID ANYTHING.
            </param>
            <param name="origin">
              The reference specifying how to apply the offset....  IF
              THIS METHOD ACTUALLY DID ANYTHING.
            </param>
            <returns>nothing. It always throws.</returns>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.SetLength(System.Int64)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="value">
              The new value for the stream length....  IF
              THIS METHOD ACTUALLY DID ANYTHING.
            </param>
        </member>
        <member name="M:Ionic.Zlib.Tree.DistanceCode(System.Int32)">
            <summary>
            Map from a distance to a distance code.
            </summary>
            <remarks> 
            No side effects. _dist_code[256] and _dist_code[257] are never used.
            </remarks>
        </member>
        <member name="T:Ionic.Zlib.FlushType">
            <summary>
            Describes how to flush the current deflate operation.
            </summary>
            <remarks>
            The different FlushType values are useful when using a Deflate in a streaming application.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.FlushType.None">
            <summary>No flush at all.</summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Partial">
            <summary>Closes the current block, but doesn't flush it to
            the output. Used internally only in hypothetical
            scenarios.  This was supposed to be removed by Zlib, but it is
            still in use in some edge cases.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Sync">
            <summary>
            Use this during compression to specify that all pending output should be
            flushed to the output buffer and the output should be aligned on a byte
            boundary.  You might use this in a streaming communication scenario, so that
            the decompressor can get all input data available so far.  When using this
            with a ZlibCodec, <c>AvailableBytesIn</c> will be zero after the call if
            enough output space has been provided before the call.  Flushing will
            degrade compression and so it should be used only when necessary.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Full">
            <summary>
            Use this during compression to specify that all output should be flushed, as
            with <c>FlushType.Sync</c>, but also, the compression state should be reset
            so that decompression can restart from this point if previous compressed
            data has been damaged or if random access is desired.  Using
            <c>FlushType.Full</c> too often can significantly degrade the compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Finish">
            <summary>Signals the end of the compression/decompression stream.</summary>
        </member>
        <member name="T:Ionic.Zlib.CompressionLevel">
            <summary>
            The compression level to be used when using a DeflateStream or ZlibStream with CompressionMode.Compress.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.None">
            <summary>
            None means that the data will be simply stored, with no change at all.
            If you are producing ZIPs for use on Mac OSX, be aware that archives produced with CompressionLevel.None
            cannot be opened with the default zip reader. Use a different CompressionLevel.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level0">
            <summary>
            Same as None.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.BestSpeed">
            <summary>
            The fastest but least effective compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level1">
            <summary>
            A synonym for BestSpeed.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level2">
            <summary>
            A little slower, but better, than level 1.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level3">
            <summary>
            A little slower, but better, than level 2.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level4">
            <summary>
            A little slower, but better, than level 3.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level5">
            <summary>
            A little slower than level 4, but with better compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Default">
            <summary>
            The default compression level, with a good balance of speed and compression efficiency.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level6">
            <summary>
            A synonym for Default.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level7">
            <summary>
            Pretty good compression!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level8">
            <summary>
             Better compression than Level7!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.BestCompression">
            <summary>
            The "best" compression, where best means greatest reduction in size of the input data stream.
            This is also the slowest compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level9">
            <summary>
            A synonym for BestCompression.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.CompressionStrategy">
            <summary>
            Describes options for how the compression algorithm is executed.  Different strategies
            work better on different sorts of data.  The strategy parameter can affect the compression
            ratio and the speed of compression but not the correctness of the compresssion.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.Default">
            <summary>
            The default strategy is probably the best for normal data.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.Filtered">
            <summary>
            The <c>Filtered</c> strategy is intended to be used most effectively with data produced by a
            filter or predictor.  By this definition, filtered data consists mostly of small
            values with a somewhat random distribution.  In this case, the compression algorithm
            is tuned to compress them better.  The effect of <c>Filtered</c> is to force more Huffman
            coding and less string matching; it is a half-step between <c>Default</c> and <c>HuffmanOnly</c>.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.HuffmanOnly">
            <summary>
            Using <c>HuffmanOnly</c> will force the compressor to do Huffman encoding only, with no
            string matching.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.CompressionMode">
            <summary>
            An enum to specify the direction of transcoding - whether to compress or decompress.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionMode.Compress">
            <summary>
            Used to specify that the stream should compress the data.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionMode.Decompress">
            <summary>
            Used to specify that the stream should decompress the data.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.ZlibException">
            <summary>
            A general purpose exception class for exceptions in the Zlib library.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibException.#ctor">
            <summary>
            The ZlibException class captures exception information generated
            by the Zlib library.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibException.#ctor(System.String)">
            <summary>
            This ctor collects a message attached to the exception.
            </summary>
            <param name="s">the message for the exception.</param>
        </member>
        <member name="M:Ionic.Zlib.SharedUtils.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:Ionic.Zlib.SharedUtils.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
             <summary>
               Reads a number of characters from the current source TextReader and writes
               the data to the target array at the specified index.
             </summary>
            
             <param name="sourceTextReader">The source TextReader to read from</param>
             <param name="target">Contains the array of characteres read from the source TextReader.</param>
             <param name="start">The starting index of the target array.</param>
             <param name="count">The maximum number of characters to read from the source TextReader.</param>
            
             <returns>
               The number of characters read. The number will be less than or equal to
               count depending on the data available in the source TextReader. Returns -1
               if the end of the stream is reached.
             </returns>
        </member>
        <member name="T:Ionic.Zlib.Adler">
             <summary>
             Computes an Adler-32 checksum.
             </summary>
             <remarks>
             The Adler checksum is similar to a CRC checksum, but faster to compute, though less
             reliable.  It is used in producing RFC1950 compressed streams.  The Adler checksum
             is a required part of the "ZLIB" standard.  Applications will almost never need to
             use this class directly.
             </remarks>
            
             <exclude/>
        </member>
        <member name="M:Ionic.Zlib.Adler.Adler32(System.UInt32,System.Byte[],System.Int32,System.Int32)">
            <summary>
              Calculates the Adler32 checksum.
            </summary>
            <remarks>
              <para>
                This is used within ZLIB.  You probably don't need to use this directly.
              </para>
            </remarks>
            <example>
               To compute an Adler32 checksum on a byte array:
             <code>
               var adler = Adler.Adler32(0, null, 0, 0);
               adler = Adler.Adler32(adler, buffer, index, length);
             </code>
            </example>
        </member>
        <member name="T:Ionic.Zlib.ZlibCodec">
             <summary>
             Encoder and Decoder for ZLIB and DEFLATE (IETF RFC1950 and RFC1951).
             </summary>
            
             <remarks>
             This class compresses and decompresses data according to the Deflate algorithm
             and optionally, the ZLIB format, as documented in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950 - ZLIB</see> and <see
             href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951 - DEFLATE</see>.
             </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.InputBuffer">
            <summary>
            The buffer from which data is taken.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.NextIn">
            <summary>
            An index into the InputBuffer array, indicating where to start reading. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.AvailableBytesIn">
            <summary>
            The number of bytes available in the InputBuffer, starting at NextIn. 
            </summary>
            <remarks>
            Generally you should set this to InputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.TotalBytesIn">
            <summary>
            Total number of bytes read so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.OutputBuffer">
            <summary>
            Buffer to store output data.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.NextOut">
            <summary>
            An index into the OutputBuffer array, indicating where to start writing. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.AvailableBytesOut">
            <summary>
            The number of bytes available in the OutputBuffer, starting at NextOut. 
            </summary>
            <remarks>
            Generally you should set this to OutputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.TotalBytesOut">
            <summary>
            Total number of bytes written to the output so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.Message">
            <summary>
            used for diagnostics, when something goes wrong!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.CompressLevel">
            <summary>
            The compression level to use in this codec.  Useful only in compression mode.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.WindowBits">
            <summary>
            The number of Window Bits to use.  
            </summary>
            <remarks>
            This gauges the size of the sliding window, and hence the 
            compression effectiveness as well as memory consumption. It's best to just leave this 
            setting alone if you don't know what it is.  The maximum value is 15 bits, which implies
            a 32k window.  
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.Strategy">
            <summary>
            The compression strategy to use.
            </summary>
            <remarks>
            This is only effective in compression.  The theory offered by ZLIB is that different
            strategies could potentially produce significant differences in compression behavior
            for different data sets.  Unfortunately I don't have any good recommendations for how
            to set it differently.  When I tested changing the strategy I got minimally different
            compression performance. It's best to leave this property alone if you don't have a
            good feel for it.  Or, you may want to produce a test harness that runs through the
            different strategy options and evaluates them on different file types. If you do that,
            let me know your results.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ZlibCodec.Adler32">
            <summary>
            The Adler32 checksum on the data transferred through the codec so far. You probably don't need to look at this.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.#ctor">
            <summary>
            Create a ZlibCodec.
            </summary>
            <remarks>
            If you use this default constructor, you will later have to explicitly call 
            InitializeInflate() or InitializeDeflate() before using the ZlibCodec to compress 
            or decompress. 
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.#ctor(Ionic.Zlib.CompressionMode)">
            <summary>
            Create a ZlibCodec that either compresses or decompresses.
            </summary>
            <param name="mode">
            Indicates whether the codec should compress (deflate) or decompress (inflate).
            </param>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate">
            <summary>
            Initialize the inflation state. 
            </summary>
            <remarks>
            It is not necessary to call this before using the ZlibCodec to inflate data; 
            It is implicitly called when you call the constructor.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to
             govern the handling of RFC1950 header bytes.
             </summary>
            
             <remarks>
             By default, the ZLIB header defined in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950</see> is expected.  If
             you want to read a zlib stream you should specify true for
             expectRfc1950Header.  If you have a deflate stream, you will want to specify
             false. It is only necessary to invoke this initializer explicitly if you
             want to specify false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte
             pair when reading the stream of data to be inflated.</param>
            
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Int32)">
            <summary>
            Initialize the ZlibCodec for inflation, with the specified number of window bits. 
            </summary>
            <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
            then you shouldn't be calling this initializer.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Int32,System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to govern the handling of
             RFC1950 header bytes. 
             </summary>
            
             <remarks>
             If you want to read a zlib stream you should specify true for
             expectRfc1950Header. In this case, the library will expect to find a ZLIB
             header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
             1950</see>, in the compressed stream.  If you will be reading a DEFLATE or
             GZIP stream, which does not have such a header, you will want to specify
             false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte pair when reading 
             the stream of data to be inflated.</param>
             <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
             then you shouldn't be calling this initializer.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.Inflate(Ionic.Zlib.FlushType)">
             <summary>
             Inflate the data in the InputBuffer, placing the result in the OutputBuffer.
             </summary>
             <remarks>
             You must have set InputBuffer and OutputBuffer, NextIn and NextOut, and AvailableBytesIn and 
             AvailableBytesOut  before calling this method.
             </remarks>
             <example>
             <code>
             private void InflateBuffer()
             {
                 int bufferSize = 1024;
                 byte[] buffer = new byte[bufferSize];
                 ZlibCodec decompressor = new ZlibCodec();
             
                 Console.WriteLine("\n============================================");
                 Console.WriteLine("Size of Buffer to Inflate: {0} bytes.", CompressedBytes.Length);
                 MemoryStream ms = new MemoryStream(DecompressedBytes);
             
                 int rc = decompressor.InitializeInflate();
             
                 decompressor.InputBuffer = CompressedBytes;
                 decompressor.NextIn = 0;
                 decompressor.AvailableBytesIn = CompressedBytes.Length;
             
                 decompressor.OutputBuffer = buffer;
             
                 // pass 1: inflate 
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.None);
             
                     if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     ms.Write(decompressor.OutputBuffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 // pass 2: finish and flush
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.Finish);
             
                     if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     if (buffer.Length - decompressor.AvailableBytesOut &gt; 0)
                         ms.Write(buffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 decompressor.EndInflate();
             }
            
             </code>
             </example>
             <param name="flush">The flush to use when inflating.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.EndInflate">
            <summary>
            Ends an inflation session. 
            </summary>
            <remarks>
            Call this after successively calling Inflate().  This will cause all buffers to be flushed. 
            After calling this you cannot call Inflate() without a intervening call to one of the
            InitializeInflate() overloads.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SyncInflate">
            <summary>
            I don't know what this does!
            </summary>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate">
            <summary>
            Initialize the ZlibCodec for deflation operation.
            </summary>
            <remarks>
            The codec will use the MAX window bits and the default level of compression.
            </remarks>
            <example>
            <code>
             int bufferSize = 40000;
             byte[] CompressedBytes = new byte[bufferSize];
             byte[] DecompressedBytes = new byte[bufferSize];
             
             ZlibCodec compressor = new ZlibCodec();
             
             compressor.InitializeDeflate(CompressionLevel.Default);
             
             compressor.InputBuffer = System.Text.ASCIIEncoding.ASCII.GetBytes(TextToCompress);
             compressor.NextIn = 0;
             compressor.AvailableBytesIn = compressor.InputBuffer.Length;
             
             compressor.OutputBuffer = CompressedBytes;
             compressor.NextOut = 0;
             compressor.AvailableBytesOut = CompressedBytes.Length;
             
             while (compressor.TotalBytesIn != TextToCompress.Length &amp;&amp; compressor.TotalBytesOut &lt; bufferSize)
             {
               compressor.Deflate(FlushType.None);
             }
             
             while (true)
             {
               int rc= compressor.Deflate(FlushType.Finish);
               if (rc == ZlibConstants.Z_STREAM_END) break;
             }
             
             compressor.EndDeflate();
              
            </code>
            </example>
            <returns>Z_OK if all goes well. You generally don't need to check the return code.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified
            CompressionLevel.  It will emit a ZLIB stream as it compresses.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Boolean)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the explicit flag governing whether to emit an RFC1950 header byte pair.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified CompressionLevel.
            If you want to generate a zlib stream, you should specify true for
            wantRfc1950Header. In this case, the library will emit a ZLIB
            header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
            1950</see>, in the compressed stream.  
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Int32)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the specified number of window bits. 
            </summary>
            <remarks>
            The codec will use the specified number of window bits and the specified CompressionLevel.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Int32,System.Boolean)">
             <summary>
             Initialize the ZlibCodec for deflation operation, using the specified
             CompressionLevel, the specified number of window bits, and the explicit flag
             governing whether to emit an RFC1950 header byte pair.
             </summary>
            
             <param name="level">The compression level for the codec.</param>
             <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
             <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
             <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.Deflate(Ionic.Zlib.FlushType)">
            <summary>
            Deflate one batch of data.
            </summary>
            <remarks>
            You must have set InputBuffer and OutputBuffer before calling this method.
            </remarks>
            <example>
            <code>
            private void DeflateBuffer(CompressionLevel level)
            {
                int bufferSize = 1024;
                byte[] buffer = new byte[bufferSize];
                ZlibCodec compressor = new ZlibCodec();
            
                Console.WriteLine("\n============================================");
                Console.WriteLine("Size of Buffer to Deflate: {0} bytes.", UncompressedBytes.Length);
                MemoryStream ms = new MemoryStream();
            
                int rc = compressor.InitializeDeflate(level);
            
                compressor.InputBuffer = UncompressedBytes;
                compressor.NextIn = 0;
                compressor.AvailableBytesIn = UncompressedBytes.Length;
            
                compressor.OutputBuffer = buffer;
            
                // pass 1: deflate 
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.None);
            
                    if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                        throw new Exception("deflating: " + compressor.Message);
            
                    ms.Write(compressor.OutputBuffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                // pass 2: finish and flush
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.Finish);
            
                    if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                        throw new Exception("deflating: " + compressor.Message);
            
                    if (buffer.Length - compressor.AvailableBytesOut &gt; 0)
                        ms.Write(buffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                compressor.EndDeflate();
            
                ms.Seek(0, SeekOrigin.Begin);
                CompressedBytes = new byte[compressor.TotalBytesOut];
                ms.Read(CompressedBytes, 0, CompressedBytes.Length);
            }
            </code>
            </example>
            <param name="flush">whether to flush all data as you deflate. Generally you will want to 
            use Z_NO_FLUSH here, in a series of calls to Deflate(), and then call EndDeflate() to 
            flush everything. 
            </param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.EndDeflate">
            <summary>
            End a deflation session.
            </summary>
            <remarks>
            Call this after making a series of one or more calls to Deflate(). All buffers are flushed.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.ResetDeflate">
            <summary>
            Reset a codec for another deflation session.
            </summary>
            <remarks>
            Call this to reset the deflation state.  For example if a thread is deflating
            non-consecutive blocks, you can call Reset() after the Deflate(Sync) of the first
            block and before the next Deflate(None) of the second block.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SetDeflateParams(Ionic.Zlib.CompressionLevel,Ionic.Zlib.CompressionStrategy)">
            <summary>
            Set the CompressionStrategy and CompressionLevel for a deflation session.
            </summary>
            <param name="level">the level of compression to use.</param>
            <param name="strategy">the strategy to use for compression.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SetDictionary(System.Byte[])">
            <summary>
            Set the dictionary to be used for either Inflation or Deflation.
            </summary>
            <param name="dictionary">The dictionary bytes to use.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="T:Ionic.Zlib.ZlibConstants">
            <summary>
            A bunch of constants used in the Zlib interface.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WindowBitsMax">
            <summary>
            The maximum number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WindowBitsDefault">
            <summary>
            The default number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_OK">
            <summary>
            indicates everything is A-OK
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_STREAM_END">
            <summary>
            Indicates that the last operation reached the end of the stream.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_NEED_DICT">
            <summary>
            The operation ended in need of a dictionary. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_STREAM_ERROR">
            <summary>
            There was an error with the stream - not enough data, not open and readable, etc.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_DATA_ERROR">
            <summary>
            There was an error with the data - not enough data, bad data, etc.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_BUF_ERROR">
            <summary>
            There was an error with the working buffer.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WorkingBufferSizeDefault">
            <summary>
            The size of the working buffer used in the ZlibCodec class. Defaults to 8192 bytes.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WorkingBufferSizeMin">
            <summary>
            The minimum size of the working buffer used in the ZlibCodec class.  Currently it is 128 bytes.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.ZlibStream">
             <summary>
             Represents a Zlib stream for compression or decompression.
             </summary>
             <remarks>
            
             <para>
             The ZlibStream is a <see
             href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see
             cref="T:System.IO.Stream"/>.  It adds ZLIB compression or decompression to any
             stream.
             </para>
            
             <para> Using this stream, applications can compress or decompress data via
             stream <c>Read()</c> and <c>Write()</c> operations.  Either compresssion or
             decompression can occur through either reading or writing. The compression
             format used is ZLIB, which is documented in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">IETF RFC 1950</see>, "ZLIB Compressed
             Data Format Specification version 3.3". This implementation of ZLIB always uses
             DEFLATE as the compression method.  (see <see
             href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
             Compressed Data Format Specification version 1.3.") </para>
            
             <para>
             The ZLIB format allows for varying compression methods, window sizes, and dictionaries.
             This implementation always uses the DEFLATE compression method, a preset dictionary,
             and 15 window bits by default.
             </para>
            
             <para>
             This class is similar to <see cref="T:Ionic.Zlib.DeflateStream"/>, except that it adds the
             RFC1950 header and trailer bytes to a compressed stream when compressing, or expects
             the RFC1950 header and trailer bytes when decompressing.  It is also similar to the
             <see cref="T:Ionic.Zlib.GZipStream"/>.
             </para>
             </remarks>
             <seealso cref="T:Ionic.Zlib.DeflateStream" />
             <seealso cref="T:Ionic.Zlib.GZipStream" />
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
             <summary>
             Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>.
             </summary>
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>ZlibStream</c>
               will use the default compression level. The "captive" stream will be
               closed when the <c>ZlibStream</c> is closed.
             </para>
            
             </remarks>
            
             <example>
             This example uses a <c>ZlibStream</c> to compress a file, and writes the
             compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".zlib"))
                 {
                     using (Stream compressor = new ZlibStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".zlib")
                 Using compressor As Stream = New ZlibStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
             <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c> and
               the specified <c>CompressionLevel</c>.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
               The "captive" stream will be closed when the <c>ZlibStream</c> is closed.
             </para>
            
             </remarks>
            
             <example>
               This example uses a <c>ZlibStream</c> to compress data from a file, and writes the
               compressed data to another file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".zlib"))
                 {
                     using (Stream compressor = new ZlibStream(raw,
                                                               CompressionMode.Compress,
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".zlib")
                     Using compressor As Stream = New ZlibStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
            
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>, and
               explicitly specify whether the captive stream should be left open after
               Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>ZlibStream</c> will use
               the default compression level.
             </para>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               <see cref="T:System.IO.MemoryStream"/> that will be re-read after
               compression.  Specify true for the <paramref name="leaveOpen"/> parameter to leave the stream
               open.
             </para>
            
             <para>
             See the other overloads of this constructor for example code.
             </para>
            
             </remarks>
            
             <param name="stream">The stream which will be read or written. This is called the
             "captive" stream in other places in this documentation.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain
             open after inflation/deflation.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>
               and the specified <c>CompressionLevel</c>, and explicitly specify
               whether the stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive
               stream remain open after the deflation or inflation occurs.  By
               default, after <c>Close()</c> is called on the stream, the captive
               stream is also closed. In some cases this is not desired, for example
               if the stream is a <see cref="T:System.IO.MemoryStream"/> that will be
               re-read after compression.  Specify true for the <paramref
               name="leaveOpen"/> parameter to leave the stream open.
             </para>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is
               ignored.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a ZlibStream to compress the data from a file,
             and store the result into another file. The filestream remains open to allow
             additional data to be written to it.
            
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".zlib"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new ZlibStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code>
             <code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".zlib")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New ZlibStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
            
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
            
             <param name="leaveOpen">
             true if the application would like the stream to remain open after
             inflation/deflation.
             </param>
            
             <param name="level">
             A tuning knob to trade speed for effectiveness. This parameter is
             effective only when mode is <c>CompressionMode.Compress</c>.
             </param>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            Sorry, though, not sure exactly how to describe all the various settings.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes. The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                This method may be invoked in two distinct scenarios.  If disposing
                == true, the method has been called directly or indirectly by a
                user's code, for example via the public Dispose() method. In this
                case, both managed and unmanaged resources can be referenced and
                disposed.  If disposing == false, the method has been called by the
                runtime from inside the object finalizer and this method should not
                reference other objects; in that case only unmanaged resources must
                be referenced or disposed.
              </para>
            </remarks>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.Position">
             <summary>
               The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotSupportedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Read data from the stream.
             </summary>
            
             <remarks>
            
             <para>
               If you wish to use the <c>ZlibStream</c> to compress data while reading,
               you can create a <c>ZlibStream</c> with <c>CompressionMode.Compress</c>,
               providing an uncompressed data stream.  Then call <c>Read()</c> on that
               <c>ZlibStream</c>, and the data read will be compressed.  If you wish to
               use the <c>ZlibStream</c> to decompress data while reading, you can create
               a <c>ZlibStream</c> with <c>CompressionMode.Decompress</c>, providing a
               readable compressed data stream.  Then call <c>Read()</c> on that
               <c>ZlibStream</c>, and the data will be decompressed as it is read.
             </para>
            
             <para>
               A <c>ZlibStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but
               not both.
             </para>
            
             </remarks>
            
             <param name="buffer">
             The buffer into which the read data should be placed.</param>
            
             <param name="offset">
             the offset within that data array to put the first byte read.</param>
            
             <param name="count">the number of bytes to read.</param>
            
             <returns>the number of bytes read</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Seek(System.Int64,System.IO.SeekOrigin)">
             <summary>
             Calling this method always throws a <see cref="T:System.NotSupportedException"/>.
             </summary>
             <param name="offset">
               The offset to seek to....
               IF THIS METHOD ACTUALLY DID ANYTHING.
             </param>
             <param name="origin">
               The reference specifying how to apply the offset....  IF
               THIS METHOD ACTUALLY DID ANYTHING.
             </param>
            
             <returns>nothing. This method always throws.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotSupportedException"/>.
            </summary>
            <param name="value">
              The new value for the stream length....  IF
              THIS METHOD ACTUALLY DID ANYTHING.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Write data to the stream.
             </summary>
            
             <remarks>
            
             <para>
               If you wish to use the <c>ZlibStream</c> to compress data while writing,
               you can create a <c>ZlibStream</c> with <c>CompressionMode.Compress</c>,
               and a writable output stream.  Then call <c>Write()</c> on that
               <c>ZlibStream</c>, providing uncompressed data as input.  The data sent to
               the output stream will be the compressed form of the data written.  If you
               wish to use the <c>ZlibStream</c> to decompress data while writing, you
               can create a <c>ZlibStream</c> with <c>CompressionMode.Decompress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that stream,
               providing previously compressed data. The data sent to the output stream
               will be the decompressed form of the data written.
             </para>
            
             <para>
               A <c>ZlibStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
             </para>
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using ZLIB.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)"/>
            
             <param name="s">
               A string to compress.  The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using ZLIB.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.ZlibStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="b">
             A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a ZLIB-compressed byte array into a single string.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.ZlibStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing ZLIB-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a ZLIB-compressed byte array into a byte array.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing ZLIB-compressed data.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
    </members>
</doc>
